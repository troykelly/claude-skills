#!/usr/bin/env bash
#
# claude-account - Manage multiple Claude Code accounts via .env
#
# Usage:
#   claude-account <command> [options]
#
# Commands:
#   capture             Save current account to .env (credentials + metadata)
#   list                Show all saved accounts
#   list --available    Show only accounts not exhausted/in cooldown
#   current             Show current active account
#   switch              Rotate to next account
#   switch <email>      Switch to specific account by email
#   remove [-f] <email> Remove a saved account from .env
#   next                Print next available account (for scripts)
#   mark-exhausted      Mark current account as plan-limit exhausted
#   reset-exhausted     Reset all exhaustion statuses
#   is-exhausted        Exit 0 if current account is exhausted, 1 otherwise
#   status              Show exhaustion status of all accounts
#
# Environment Variables:
#   CLAUDE_ENV_FILE     Path to .env file (default: ./.env)
#   CLAUDE_CONFIG_DIR   Claude Code config directory (set by Claude Code in devcontainers)
#                       If set: config at $CLAUDE_CONFIG_DIR/.claude.json
#                       If not set: config at ~/.claude.json
#
# Storage Format in .env:
#   CLAUDE_ACCOUNT_<EMAIL>_ACCESSTOKEN=sk-ant-oat01-...
#   CLAUDE_ACCOUNT_<EMAIL>_REFRESHTOKEN=sk-ant-ort01-...
#   CLAUDE_ACCOUNT_<EMAIL>_EXPIRESAT=1234567890
#   CLAUDE_ACCOUNT_<EMAIL>_EMAILADDRESS=user@example.com
#   CLAUDE_ACCOUNT_<EMAIL>_ACCOUNTUUID=...
#   CLAUDE_ACCOUNT_<EMAIL>_ORGANIZATIONUUID=...
#   CLAUDE_ACCOUNT_<EMAIL>_DISPLAYNAME=...
#
# Config: $CLAUDE_CONFIG_DIR/.claude.json or ~/.claude.json (account metadata)
# Credentials: macOS Keychain / Linux $CLAUDE_CONFIG_DIR/.credentials.json
#
# Tip: Sync your .env to 1Password for persistence across devcontainer rebuilds

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# Files - Claude Code config location depends on CLAUDE_CONFIG_DIR
# If CLAUDE_CONFIG_DIR is set: $CLAUDE_CONFIG_DIR/.claude.json
# Otherwise: ~/.claude.json (default)
CLAUDE_CONFIG_DIR="${CLAUDE_CONFIG_DIR:-}"
if [[ -n "$CLAUDE_CONFIG_DIR" ]]; then
  CLAUDE_CONFIG="${CLAUDE_CONFIG_DIR}/.claude.json"
  CLAUDE_CREDENTIALS="${CLAUDE_CONFIG_DIR}/.credentials.json"
else
  CLAUDE_CONFIG="${HOME}/.claude.json"
  CLAUDE_CREDENTIALS="${HOME}/.claude/.credentials.json"
fi
ENV_FILE="${CLAUDE_ENV_FILE:-./.env}"
# Exhaustion file goes in same directory as config
if [[ -n "$CLAUDE_CONFIG_DIR" ]]; then
  EXHAUSTION_FILE="${CLAUDE_CONFIG_DIR}/.account-exhaustion.json"
else
  EXHAUSTION_FILE="${HOME}/.claude/.account-exhaustion.json"
fi

# Keychain service name (macOS)
KEYCHAIN_SERVICE="Claude Code-credentials"

# Exhaustion tracking configuration
COOLDOWN_MINUTES="${CLAUDE_ACCOUNT_COOLDOWN_MINUTES:-5}"

# Temp file tracking for cleanup
TEMP_FILES=()
cleanup_temp_files() {
  if [[ ${#TEMP_FILES[@]} -gt 0 ]]; then
    for f in "${TEMP_FILES[@]}"; do
      [[ -f "$f" ]] && rm -f "$f"
    done
  fi
}
trap cleanup_temp_files EXIT

make_temp() {
  local tmp
  tmp=$(mktemp)
  TEMP_FILES+=("$tmp")
  echo "$tmp"
}

# Check dependencies
check_deps() {
  local missing=()
  if ! command -v jq &>/dev/null; then
    missing+=("jq")
  fi
  if [[ ${#missing[@]} -gt 0 ]]; then
    echo -e "${RED}Error: Missing required dependencies: ${missing[*]}${NC}"
    echo "Install with: brew install ${missing[*]} / apt-get install ${missing[*]}"
    exit 1
  fi
}

# Detect OS and credential storage method
detect_credential_storage() {
  if [[ "$OSTYPE" == "darwin"* ]]; then
    echo "keychain"
  else
    # Linux/other: use file-based storage (Claude Code uses ~/.claude/.credentials.json)
    echo "file"
  fi
}

# Sanitize email for env var name (replace non-alphanumeric with _)
sanitize_email() {
  local email="$1"
  echo "$email" | sed 's/[^a-zA-Z0-9]/_/g' | tr '[:lower:]' '[:upper:]'
}

# Check if email is in comma-separated list (literal match, no regex)
email_in_list() {
  local email="$1"
  local list="$2"
  [[ ",${list}," == *",${email},"* ]]
}

# Parse comma-separated list into array, filtering empty elements
# Note: Uses nameref which requires bash 4.3+. macOS default is 3.2 but Homebrew bash is typically 5.x
parse_email_list() {
  local list="$1"
  local -n result_array="$2"
  result_array=()
  local temp_array
  IFS=',' read -ra temp_array <<< "$list"
  local email
  for email in "${temp_array[@]}"; do
    [[ -n "$email" ]] && result_array+=("$email")
  done
}

# Get oauthAccount from config file
get_oauth_account() {
  if [[ ! -f "$CLAUDE_CONFIG" ]] || [[ ! -s "$CLAUDE_CONFIG" ]]; then
    echo ""
    return
  fi

  jq -c '.oauthAccount // empty' "$CLAUDE_CONFIG" 2>/dev/null || echo ""
}

# Get current email from ~/.claude.json or credentials
get_current_email() {
  local account email
  account=$(get_oauth_account)
  if [[ -n "$account" ]]; then
    email=$(echo "$account" | jq -r '.emailAddress // empty')
    if [[ -n "$email" ]]; then
      echo "$email"
      return
    fi
  fi

  # Fallback: try to get from credentials file (Linux/devcontainer)
  if [[ -f "$CLAUDE_CREDENTIALS" ]]; then
    # Some credential formats may contain email in different locations
    email=$(jq -r '.claudeAiOauth.email // .email // empty' "$CLAUDE_CREDENTIALS" 2>/dev/null)
    if [[ -n "$email" ]]; then
      echo "$email"
      return
    fi
  fi

  # Final fallback: check if any saved account matches current credentials
  local creds access_token
  creds=$(get_credentials)
  if [[ -n "$creds" ]]; then
    access_token=$(echo "$creds" | jq -r '.claudeAiOauth.accessToken // empty' 2>/dev/null)
    if [[ -n "$access_token" ]]; then
      # Check saved accounts for matching token
      local accounts_list
      accounts_list=$(get_accounts_list)
      if [[ -n "$accounts_list" ]]; then
        local emails
        parse_email_list "$accounts_list" emails
        for saved_email in "${emails[@]}"; do
          local saved_token
          saved_token=$(get_account_field "$saved_email" "ACCESSTOKEN")
          if [[ "$saved_token" == "$access_token" ]]; then
            echo "$saved_email"
            return
          fi
        done
      fi
    fi
  fi
}

# Get credentials from storage (macOS Keychain or Linux file)
get_credentials() {
  local storage_type
  storage_type=$(detect_credential_storage)

  case "$storage_type" in
    keychain)
      security find-generic-password -s "$KEYCHAIN_SERVICE" -a "$USER" -w 2>/dev/null || echo ""
      ;;
    file)
      cat "$CLAUDE_CREDENTIALS" 2>/dev/null || echo ""
      ;;
    *)
      echo ""
      ;;
  esac
}

# Set credentials in storage (macOS Keychain or Linux file)
set_credentials() {
  local creds="$1"
  local storage_type
  storage_type=$(detect_credential_storage)

  case "$storage_type" in
    keychain)
      # Delete existing entry first (ignore errors if doesn't exist)
      security delete-generic-password -s "$KEYCHAIN_SERVICE" -a "$USER" 2>/dev/null || true
      # Add new entry
      security add-generic-password -s "$KEYCHAIN_SERVICE" -a "$USER" -w "$creds"
      ;;
    file)
      # Ensure directory exists
      mkdir -p "$(dirname "$CLAUDE_CREDENTIALS")"
      # Write credentials with secure permissions
      echo "$creds" > "$CLAUDE_CREDENTIALS"
      chmod 600 "$CLAUDE_CREDENTIALS"
      ;;
    *)
      echo -e "${RED}Error: No credential storage available${NC}"
      return 1
      ;;
  esac
}

# Get accounts list from environment (derived from CLAUDE_ACCOUNT_*_EMAILADDRESS variables)
get_accounts_list() {
  local emails=""
  local var value
  # Find all CLAUDE_ACCOUNT_*_EMAILADDRESS variables
  while IFS='=' read -r var value; do
    if [[ "$var" =~ ^CLAUDE_ACCOUNT_.*_EMAILADDRESS$ ]]; then
      value="${value//\"/}"  # Remove quotes
      if [[ -n "$value" ]]; then
        [[ -n "$emails" ]] && emails="${emails},"
        emails="${emails}${value}"
      fi
    fi
  done < <(env)
  echo "$emails"
}

# Get accounts list from .env file (derived from CLAUDE_ACCOUNT_*_EMAILADDRESS lines)
get_accounts_list_from_file() {
  if [[ ! -f "$ENV_FILE" ]]; then
    echo ""
    return
  fi
  local emails=""
  local value
  while IFS='=' read -r _ value; do
    value="${value//\"/}"  # Remove quotes
    if [[ -n "$value" ]]; then
      [[ -n "$emails" ]] && emails="${emails},"
      emails="${emails}${value}"
    fi
  done < <(grep "^CLAUDE_ACCOUNT_.*_EMAILADDRESS=" "$ENV_FILE" 2>/dev/null)
  echo "$emails"
}

# Get account field from environment
get_account_field() {
  local email="$1"
  local field="$2"
  local var_name="CLAUDE_ACCOUNT_$(sanitize_email "$email")_${field}"
  echo "${!var_name:-}"
}

# Escape value for double-quoted shell string
# Escapes: \ $ ` " ! (the characters that are special inside double quotes)
escape_for_double_quotes() {
  local value="$1"
  # Order matters: escape backslashes first, then the rest
  value="${value//\\/\\\\}"   # \ -> \\
  value="${value//\$/\\\$}"   # $ -> \$
  value="${value//\`/\\\`}"   # ` -> \`
  value="${value//\"/\\\"}"   # " -> \"
  value="${value//\!/\\!}"    # ! -> \! (history expansion in interactive bash)
  echo "$value"
}

# Update or add line in .env
update_env_line() {
  local key="$1"
  local value="$2"

  # Create .env if doesn't exist, with secure permissions
  if [[ ! -f "$ENV_FILE" ]]; then
    touch "$ENV_FILE"
    chmod 600 "$ENV_FILE"
  fi

  # Remove existing line if present
  if grep -q "^${key}=" "$ENV_FILE" 2>/dev/null; then
    local temp_file
    temp_file=$(make_temp)
    grep -v "^${key}=" "$ENV_FILE" > "$temp_file"
    mv "$temp_file" "$ENV_FILE"
  fi

  # Ensure file ends with newline before appending
  if [[ -s "$ENV_FILE" ]] && [[ $(tail -c 1 "$ENV_FILE" | wc -l) -eq 0 ]]; then
    echo "" >> "$ENV_FILE"
  fi

  # Escape value and wrap in double quotes for shell safety
  local escaped_value
  escaped_value=$(escape_for_double_quotes "$value")
  printf '%s="%s"\n' "$key" "$escaped_value" >> "$ENV_FILE"
}

# Remove lines matching prefix from .env
remove_env_prefix() {
  local prefix="$1"

  if [[ ! -f "$ENV_FILE" ]]; then
    return
  fi

  local temp_file
  temp_file=$(make_temp)
  grep -v "^${prefix}" "$ENV_FILE" > "$temp_file" || true
  mv "$temp_file" "$ENV_FILE"
}

# Write header comment on first capture (idempotent - won't duplicate)
write_header() {
  # Skip if header already exists
  if [[ -f "$ENV_FILE" ]] && grep -q "^# Claude Code Account Management" "$ENV_FILE" 2>/dev/null; then
    return
  fi

  if [[ -s "$ENV_FILE" ]] && [[ $(tail -c 1 "$ENV_FILE" | wc -l) -eq 0 ]]; then
    echo "" >> "$ENV_FILE"
  fi
  cat >> "$ENV_FILE" << 'EOF'

# Claude Code Account Management
# --------------------------------
# These variables store Claude Code OAuth credentials for multi-account switching.
# Managed by: claude-account (https://github.com/troykelly/claude-skills)
#
# Commands:
#   claude-account list              Show all saved accounts
#   claude-account switch            Rotate to next account
#   claude-account switch <email>    Switch to specific account
#   claude-account current           Show current active account
#   claude-account capture           Save current account (re-run after login)
#
# Tip: Sync this .env to 1Password for persistence across devcontainer rebuilds.
#
EOF
}

# List all saved accounts
list_accounts() {
  local accounts_list
  accounts_list=$(get_accounts_list)

  if [[ -z "$accounts_list" ]]; then
    echo -e "${YELLOW}No accounts found in environment${NC}"
    echo ""
    echo "Either:"
    echo "  1. Run 'claude-account capture' to save the current account"
    echo "  2. Ensure your .env is loaded (direnv, source .env, etc.)"
    return
  fi

  local current_email
  current_email=$(get_current_email)

  echo -e "${CYAN}Saved Claude Accounts (from environment):${NC}"
  echo ""

  local count=0
  local emails
  parse_email_list "$accounts_list" emails
  for email in "${emails[@]}"; do
    local display_name org_name has_token

    display_name=$(get_account_field "$email" "DISPLAYNAME")
    org_name=$(get_account_field "$email" "ORGANIZATIONNAME")
    has_token=$(get_account_field "$email" "ACCESSTOKEN")

    if [[ "$email" == "$current_email" ]]; then
      echo -e "  ${GREEN}*${NC} ${BOLD}${email}${NC} ${GREEN}(active)${NC}"
    else
      echo -e "    ${email}"
    fi

    if [[ -n "$display_name" ]]; then
      echo -e "      ${BLUE}Name:${NC} ${display_name}"
    fi
    if [[ -n "$org_name" ]]; then
      echo -e "      ${BLUE}Org:${NC}  ${org_name}"
    fi
    if [[ -n "$has_token" ]]; then
      echo -e "      ${GREEN}Credentials:${NC} saved"
    else
      echo -e "      ${RED}Credentials:${NC} missing"
    fi
    echo ""
    count=$((count + 1))
  done

  echo -e "${BLUE}Total:${NC} ${count} account(s)"
}

# Capture current account
capture_account() {
  local cred_storage
  cred_storage=$(detect_credential_storage)

  # Get account metadata from ~/.claude.json
  local oauth_account
  oauth_account=$(get_oauth_account)

  if [[ -z "$oauth_account" ]]; then
    echo -e "${RED}Error: No account found in Claude Code config${NC}"
    echo "Expected: ${CLAUDE_CONFIG}"
    [[ -n "$CLAUDE_CONFIG_DIR" ]] && echo "  (CLAUDE_CONFIG_DIR=${CLAUDE_CONFIG_DIR})"
    echo ""
    echo "Log in to Claude Code first with: claude"
    exit 1
  fi

  local current_email
  current_email=$(echo "$oauth_account" | jq -r '.emailAddress')

  if [[ -z "$current_email" || "$current_email" == "null" ]]; then
    echo -e "${RED}Error: Could not read email from current account${NC}"
    exit 1
  fi

  # Get credentials from storage (keychain on macOS, file on Linux)
  local credentials=""
  if [[ "$cred_storage" == "keychain" || "$cred_storage" == "file" ]]; then
    credentials=$(get_credentials)
    if [[ -z "$credentials" ]]; then
      echo -e "${RED}Error: Could not read credentials from ${cred_storage}${NC}"
      echo "Make sure you're logged in to Claude Code."
      exit 1
    fi
  else
    echo -e "${YELLOW}Warning: Credential storage not available${NC}"
    echo "Saving account metadata only - tokens will not be saved."
  fi

  # Add header if not present (idempotent)
  write_header

  # Build env var prefix
  local prefix="CLAUDE_ACCOUNT_$(sanitize_email "$current_email")"

  # Remove any existing entries for this account
  remove_env_prefix "${prefix}_"

  # Save account metadata fields
  update_env_line "${prefix}_EMAILADDRESS" "$current_email"
  update_env_line "${prefix}_ACCOUNTUUID" "$(echo "$oauth_account" | jq -r '.accountUuid // ""')"
  update_env_line "${prefix}_ORGANIZATIONUUID" "$(echo "$oauth_account" | jq -r '.organizationUuid // ""')"
  update_env_line "${prefix}_DISPLAYNAME" "$(echo "$oauth_account" | jq -r '.displayName // ""')"
  update_env_line "${prefix}_ORGANIZATIONNAME" "$(echo "$oauth_account" | jq -r '.organizationName // ""')"
  update_env_line "${prefix}_ORGANIZATIONROLE" "$(echo "$oauth_account" | jq -r '.organizationRole // ""')"
  update_env_line "${prefix}_HASEXTRAUSAGEENABLED" "$(echo "$oauth_account" | jq -r '.hasExtraUsageEnabled // ""')"

  # Save credentials if available
  if [[ -n "$credentials" ]]; then
    local oauth_creds
    oauth_creds=$(echo "$credentials" | jq -r '.claudeAiOauth // empty')
    if [[ -n "$oauth_creds" ]]; then
      update_env_line "${prefix}_ACCESSTOKEN" "$(echo "$oauth_creds" | jq -r '.accessToken // ""')"
      update_env_line "${prefix}_REFRESHTOKEN" "$(echo "$oauth_creds" | jq -r '.refreshToken // ""')"
      update_env_line "${prefix}_EXPIRESAT" "$(echo "$oauth_creds" | jq -r '.expiresAt // ""')"
      update_env_line "${prefix}_SCOPES" "$(echo "$oauth_creds" | jq -r '(.scopes // []) | join(",")')"
      update_env_line "${prefix}_SUBSCRIPTIONTYPE" "$(echo "$oauth_creds" | jq -r '.subscriptionType // ""')"
      update_env_line "${prefix}_RATELIMITTIER" "$(echo "$oauth_creds" | jq -r '.rateLimitTier // ""')"
    fi
  fi

  echo -e "${GREEN}Captured account:${NC} ${current_email}"
  echo -e "${BLUE}Saved to:${NC} ${ENV_FILE}"

  # Show count
  local accounts_list emails
  accounts_list=$(get_accounts_list_from_file)
  parse_email_list "$accounts_list" emails
  echo -e "${BLUE}Total saved:${NC} ${#emails[@]} account(s)"
  echo ""
  echo -e "${YELLOW}Tip:${NC} Add ${ENV_FILE} to 1Password for persistence across rebuilds"
}

# Show current account
show_current() {
  local current_email oauth_account
  current_email=$(get_current_email)
  oauth_account=$(get_oauth_account)

  if [[ -z "$current_email" ]]; then
    echo -e "${YELLOW}No account currently logged in.${NC}"
    return
  fi

  echo -e "${CYAN}Current Account:${NC}"
  echo ""
  echo -e "  ${BOLD}${current_email}${NC}"
  echo -e "  ${BLUE}Name:${NC}    $(echo "$oauth_account" | jq -r '.displayName // "N/A"')"
  echo -e "  ${BLUE}Org:${NC}     $(echo "$oauth_account" | jq -r '.organizationName // "N/A"')"
  echo -e "  ${BLUE}Role:${NC}    $(echo "$oauth_account" | jq -r '.organizationRole // "N/A"')"
  echo -e "  ${BLUE}UUID:${NC}    $(echo "$oauth_account" | jq -r '.accountUuid // "N/A"')"

  # Check if saved in env
  local accounts_list
  accounts_list=$(get_accounts_list)
  if email_in_list "$current_email" "$accounts_list"; then
    echo -e "  ${GREEN}Status:${NC}  Saved in .env"
  else
    echo -e "  ${YELLOW}Status:${NC}  Not saved (use 'claude-account capture')"
  fi
}

# Switch account
switch_account() {
  local target_email="${1:-}"

  local accounts_list
  accounts_list=$(get_accounts_list)

  if [[ -z "$accounts_list" ]]; then
    echo -e "${RED}Error: No accounts found in environment${NC}"
    echo ""
    echo "Either:"
    echo "  1. Run 'claude-account capture' to save accounts"
    echo "  2. Ensure your .env is loaded (direnv, source .env, etc.)"
    exit 1
  fi

  local emails
  parse_email_list "$accounts_list" emails
  local account_count=${#emails[@]}

  if [[ $account_count -eq 0 ]]; then
    echo -e "${RED}Error: No accounts found.${NC}"
    exit 1
  fi

  if [[ $account_count -eq 1 ]]; then
    echo -e "${YELLOW}Only one account in environment. Nothing to switch to.${NC}"
    exit 0
  fi

  local current_email new_email
  current_email=$(get_current_email)

  if [[ -n "$target_email" ]]; then
    if ! email_in_list "$target_email" "$accounts_list"; then
      echo -e "${RED}Error: Account not found: ${target_email}${NC}"
      echo ""
      echo "Available accounts:"
      printf '  %s\n' "${emails[@]}"
      exit 1
    fi
    new_email="$target_email"
  else
    # Rotate to next account
    local found_current=false
    new_email=""

    for email in "${emails[@]}"; do
      if [[ "$found_current" == "true" ]]; then
        new_email="$email"
        break
      fi
      if [[ "$email" == "$current_email" ]]; then
        found_current=true
      fi
    done

    if [[ -z "$new_email" ]]; then
      new_email="${emails[0]}"
    fi
  fi

  if [[ "$new_email" == "$current_email" ]]; then
    echo -e "${YELLOW}Already using account: ${new_email}${NC}"
    exit 0
  fi

  # Check we have credentials for the new account
  local prefix="CLAUDE_ACCOUNT_$(sanitize_email "$new_email")"
  local access_token
  access_token=$(get_account_field "$new_email" "ACCESSTOKEN")

  if [[ -z "$access_token" ]]; then
    echo -e "${RED}Error: No credentials found for: ${new_email}${NC}"
    echo "The account metadata exists but tokens are missing."
    exit 1
  fi

  # Verify config file exists
  if [[ ! -f "$CLAUDE_CONFIG" ]] || [[ ! -s "$CLAUDE_CONFIG" ]]; then
    echo -e "${RED}Error: No Claude Code config file found${NC}"
    echo "Expected: ${CLAUDE_CONFIG}"
    [[ -n "$CLAUDE_CONFIG_DIR" ]] && echo "  (CLAUDE_CONFIG_DIR=${CLAUDE_CONFIG_DIR})"
    exit 1
  fi

  # Backup current config
  local backup_file="${CLAUDE_CONFIG}.backup.$(date +%Y%m%d_%H%M%S)"
  cp "$CLAUDE_CONFIG" "$backup_file"
  echo -e "${BLUE}Backup:${NC} ${backup_file}"

  # Build new oauthAccount JSON
  local has_extra_usage
  has_extra_usage=$(get_account_field "$new_email" "HASEXTRAUSAGEENABLED")
  # Exact string match for boolean (not substring match)
  [[ "$has_extra_usage" == "true" ]] && has_extra_usage="true" || has_extra_usage="false"

  local new_oauth_account
  new_oauth_account=$(jq -n \
    --arg accountUuid "$(get_account_field "$new_email" "ACCOUNTUUID")" \
    --arg emailAddress "$(get_account_field "$new_email" "EMAILADDRESS")" \
    --arg organizationUuid "$(get_account_field "$new_email" "ORGANIZATIONUUID")" \
    --arg displayName "$(get_account_field "$new_email" "DISPLAYNAME")" \
    --arg organizationName "$(get_account_field "$new_email" "ORGANIZATIONNAME")" \
    --arg organizationRole "$(get_account_field "$new_email" "ORGANIZATIONROLE")" \
    --argjson hasExtraUsageEnabled "$has_extra_usage" \
    '{
      accountUuid: $accountUuid,
      emailAddress: $emailAddress,
      organizationUuid: $organizationUuid,
      hasExtraUsageEnabled: $hasExtraUsageEnabled,
      displayName: $displayName,
      organizationRole: $organizationRole,
      workspaceRole: null,
      organizationName: $organizationName
    }')

  # Update Claude Code config file
  local temp_file
  temp_file=$(make_temp)
  jq --argjson new_account "$new_oauth_account" '.oauthAccount = $new_account' "$CLAUDE_CONFIG" > "$temp_file"
  mv "$temp_file" "$CLAUDE_CONFIG"

  # Build new credentials JSON and update keychain
  local scopes_json expires_at_val
  scopes_json=$(get_account_field "$new_email" "SCOPES" | tr ',' '\n' | jq -R . | jq -s .)
  expires_at_val=$(get_account_field "$new_email" "EXPIRESAT")
  # Default to 0 if empty (jq --argjson fails on empty string)
  [[ -z "$expires_at_val" ]] && expires_at_val="0"

  local new_credentials
  new_credentials=$(jq -n \
    --arg accessToken "$(get_account_field "$new_email" "ACCESSTOKEN")" \
    --arg refreshToken "$(get_account_field "$new_email" "REFRESHTOKEN")" \
    --argjson expiresAt "$expires_at_val" \
    --argjson scopes "$scopes_json" \
    --arg subscriptionType "$(get_account_field "$new_email" "SUBSCRIPTIONTYPE")" \
    --arg rateLimitTier "$(get_account_field "$new_email" "RATELIMITTIER")" \
    '{claudeAiOauth: {
      accessToken: $accessToken,
      refreshToken: $refreshToken,
      expiresAt: $expiresAt,
      scopes: $scopes,
      subscriptionType: $subscriptionType,
      rateLimitTier: $rateLimitTier
    }}')

  local cred_storage
  cred_storage=$(detect_credential_storage)
  if [[ "$cred_storage" == "keychain" || "$cred_storage" == "file" ]]; then
    set_credentials "$new_credentials"
    echo -e "${GREEN}Updated credentials (${cred_storage})${NC}"
  fi

  echo -e "${GREEN}Switched account:${NC}"
  echo -e "  ${YELLOW}From:${NC} ${current_email:-"(none)"}"
  echo -e "  ${GREEN}To:${NC}   ${new_email}"
  echo ""
  echo -e "${BLUE}Note:${NC} Restart any running Claude Code sessions for changes to take effect."
}

# Remove a saved account
remove_account() {
  local force=false
  local target_email=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -f|--force)
        force=true
        shift
        ;;
      *)
        target_email="$1"
        shift
        ;;
    esac
  done

  if [[ -z "$target_email" ]]; then
    echo -e "${RED}Error: Email required${NC}"
    echo "Usage: claude-account remove [-f|--force] <email>"
    exit 1
  fi

  local accounts_list
  accounts_list=$(get_accounts_list_from_file)

  if [[ -z "$accounts_list" ]]; then
    echo -e "${RED}Error: No accounts saved in ${ENV_FILE}${NC}"
    exit 1
  fi

  if ! email_in_list "$target_email" "$accounts_list"; then
    echo -e "${RED}Error: Account not found in ${ENV_FILE}: ${target_email}${NC}"
    exit 1
  fi

  if [[ "$force" != "true" ]]; then
    echo -e "${YELLOW}Remove account: ${target_email}${NC}"
    echo -n "Are you sure? [y/N] "
    read -r confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
      echo "Cancelled."
      exit 0
    fi
  fi

  # Remove all account fields (accounts list is derived, no need to update it)
  local prefix="CLAUDE_ACCOUNT_$(sanitize_email "$target_email")"
  remove_env_prefix "${prefix}_"

  echo -e "${GREEN}Removed account:${NC} ${target_email}"
}

# Initialize exhaustion tracking file
init_exhaustion_file() {
  if [[ ! -f "$EXHAUSTION_FILE" ]]; then
    mkdir -p "$(dirname "$EXHAUSTION_FILE")"
    cat > "$EXHAUSTION_FILE" << EOF
{
  "exhausted": {},
  "switches": [],
  "cooldown_minutes": $COOLDOWN_MINUTES
}
EOF
    chmod 600 "$EXHAUSTION_FILE"
  fi
}

# Check if an account has cooled down from exhaustion
is_account_cooled_down() {
  local email="$1"

  init_exhaustion_file

  local exhausted_at
  exhausted_at=$(jq -r --arg email "$email" '.exhausted[$email] // empty' "$EXHAUSTION_FILE" 2>/dev/null)

  if [[ -z "$exhausted_at" ]]; then
    return 0  # Not exhausted, so "cooled down"
  fi

  # Convert ISO timestamp to epoch
  local exhausted_epoch now cooldown_seconds
  if [[ "$OSTYPE" == "darwin"* ]]; then
    exhausted_epoch=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$exhausted_at" +%s 2>/dev/null || echo 0)
  else
    exhausted_epoch=$(date -d "$exhausted_at" +%s 2>/dev/null || echo 0)
  fi

  now=$(date +%s)
  cooldown_seconds=$((COOLDOWN_MINUTES * 60))

  [[ $((now - exhausted_epoch)) -ge $cooldown_seconds ]]
}

# Mark an account as exhausted
mark_account_exhausted() {
  local email="${1:-$(get_current_email)}"

  if [[ -z "$email" ]]; then
    echo -e "${RED}Error: No account specified and no current account found${NC}"
    exit 1
  fi

  init_exhaustion_file

  local timestamp
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  local tmp_file
  tmp_file=$(make_temp)
  jq --arg email "$email" --arg ts "$timestamp" \
    '.exhausted[$email] = $ts' "$EXHAUSTION_FILE" > "$tmp_file"
  mv "$tmp_file" "$EXHAUSTION_FILE"

  echo -e "${YELLOW}Marked as exhausted:${NC} ${email}"
  echo -e "${BLUE}Cooldown:${NC} ${COOLDOWN_MINUTES} minutes"
}

# Reset all exhaustion statuses
reset_exhausted() {
  init_exhaustion_file

  local tmp_file
  tmp_file=$(make_temp)
  jq '.exhausted = {} | .switches = []' "$EXHAUSTION_FILE" > "$tmp_file"
  mv "$tmp_file" "$EXHAUSTION_FILE"

  echo -e "${GREEN}Reset all exhaustion statuses${NC}"
}

# Check if current account is exhausted
check_is_exhausted() {
  local current_email
  current_email=$(get_current_email)

  if [[ -z "$current_email" ]]; then
    echo -e "${RED}Error: No current account found${NC}" >&2
    exit 1
  fi

  if is_account_cooled_down "$current_email"; then
    exit 1  # Not exhausted (or cooled down)
  else
    exit 0  # Still exhausted
  fi
}

# Get next available account (not exhausted or cooled down)
get_next_available_account() {
  local current_email
  current_email=$(get_current_email)

  local accounts_list
  accounts_list=$(get_accounts_list)

  if [[ -z "$accounts_list" ]]; then
    return 1
  fi

  local emails
  parse_email_list "$accounts_list" emails

  # Find next available account (round-robin from current)
  local found_current=false
  local candidate=""

  # First pass: find accounts after current
  for email in "${emails[@]}"; do
    if [[ "$found_current" == "true" ]]; then
      if [[ "$email" != "$current_email" ]] && is_account_cooled_down "$email"; then
        candidate="$email"
        break
      fi
    fi
    if [[ "$email" == "$current_email" ]]; then
      found_current=true
    fi
  done

  # Second pass: wrap around to beginning
  if [[ -z "$candidate" ]]; then
    for email in "${emails[@]}"; do
      if [[ "$email" == "$current_email" ]]; then
        break
      fi
      if is_account_cooled_down "$email"; then
        candidate="$email"
        break
      fi
    done
  fi

  if [[ -n "$candidate" ]]; then
    echo "$candidate"
    return 0
  fi

  return 1
}

# Print next available account for scripts
print_next_account() {
  local next
  if next=$(get_next_available_account); then
    echo "$next"
  else
    echo -e "${RED}No available accounts${NC}" >&2
    exit 1
  fi
}

# Show exhaustion status of all accounts
show_exhaustion_status() {
  init_exhaustion_file

  local accounts_list
  accounts_list=$(get_accounts_list)

  if [[ -z "$accounts_list" ]]; then
    echo -e "${YELLOW}No accounts found in environment${NC}"
    return
  fi

  local current_email
  current_email=$(get_current_email)

  echo -e "${CYAN}Account Exhaustion Status:${NC}"
  echo ""

  local emails
  parse_email_list "$accounts_list" emails

  for email in "${emails[@]}"; do
    local exhausted_at status_icon status_text remaining

    exhausted_at=$(jq -r --arg email "$email" '.exhausted[$email] // empty' "$EXHAUSTION_FILE" 2>/dev/null)

    if [[ -z "$exhausted_at" ]]; then
      status_icon="${GREEN}*${NC}"
      status_text="${GREEN}available${NC}"
    elif is_account_cooled_down "$email"; then
      status_icon="${GREEN}*${NC}"
      status_text="${GREEN}cooled down${NC}"
    else
      status_icon="${RED}!${NC}"
      # Calculate remaining cooldown
      local exhausted_epoch now elapsed remaining_secs remaining_mins
      if [[ "$OSTYPE" == "darwin"* ]]; then
        exhausted_epoch=$(date -j -f "%Y-%m-%dT%H:%M:%SZ" "$exhausted_at" +%s 2>/dev/null || echo 0)
      else
        exhausted_epoch=$(date -d "$exhausted_at" +%s 2>/dev/null || echo 0)
      fi
      now=$(date +%s)
      elapsed=$((now - exhausted_epoch))
      remaining_secs=$((COOLDOWN_MINUTES * 60 - elapsed))
      remaining_mins=$(( (remaining_secs + 59) / 60 ))  # Round up
      status_text="${RED}exhausted${NC} (${remaining_mins}m remaining)"
    fi

    if [[ "$email" == "$current_email" ]]; then
      echo -e "  ${status_icon} ${BOLD}${email}${NC} ${BLUE}(current)${NC} - ${status_text}"
    else
      echo -e "  ${status_icon} ${email} - ${status_text}"
    fi
  done

  echo ""
  echo -e "${BLUE}Cooldown period:${NC} ${COOLDOWN_MINUTES} minutes"
}

# List accounts with --available filter
list_accounts_filtered() {
  local show_available_only=false

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --available|-a)
        show_available_only=true
        shift
        ;;
      *)
        shift
        ;;
    esac
  done

  if [[ "$show_available_only" == "true" ]]; then
    # Just print available account emails (for scripts)
    local accounts_list
    accounts_list=$(get_accounts_list)

    if [[ -z "$accounts_list" ]]; then
      return
    fi

    local emails
    parse_email_list "$accounts_list" emails

    for email in "${emails[@]}"; do
      if is_account_cooled_down "$email"; then
        echo "$email"
      fi
    done
  else
    # Normal list display
    list_accounts
  fi
}

# Show help
show_help() {
  head -45 "$0" | grep -E "^#" | sed 's/^# *//' | sed 's/^#//'
}

# Main
main() {
  check_deps

  local command="${1:-}"
  shift || true

  case "$command" in
    capture)
      capture_account
      ;;
    list|ls)
      list_accounts_filtered "$@"
      ;;
    current)
      show_current
      ;;
    switch)
      switch_account "${1:-}"
      ;;
    remove|rm)
      remove_account "$@"
      ;;
    next)
      print_next_account
      ;;
    mark-exhausted)
      mark_account_exhausted "${1:-}"
      ;;
    reset-exhausted)
      reset_exhausted
      ;;
    is-exhausted)
      check_is_exhausted
      ;;
    status)
      show_exhaustion_status
      ;;
    -h|--help|help|"")
      show_help
      ;;
    *)
      echo -e "${RED}Unknown command: ${command}${NC}"
      echo "Use 'claude-account --help' for usage."
      exit 1
      ;;
  esac
}

main "$@"
