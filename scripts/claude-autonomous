#!/usr/bin/env bash
#
# claude-autonomous - Start autonomous issue-driven development with Claude
#
# Usage:
#   claude-autonomous [OPTIONS]
#
# Options:
#   -e, --epic <N>       Focus on specific epic number
#   -n, --new            Interactive mode: bootstrap and wait for instructions
#   -c, --continue       Resume the most recent session (uses Claude's native --continue)
#   --resume [ID]        Resume a session: opens Claude's picker, or resumes specific ID
#   -l, --list           List worktree session history
#   -r, --repo <path>    Repository path (default: current directory)
#   -h, --help           Show this help message
#
# Environment Variables:
#   WORK_EPIC            Same as --epic
#   GITHUB_TOKEN         GitHub token for MCP servers (auto-fetched from gh if not set)
#   MAX_CRASHES          Maximum crashes before giving up (default: 10)
#
# Note: Uses claude-opus-4-5-20251101 (Opus 4.5) as the default model
#
# Examples:
#   claude-autonomous                    # Work on all issues
#   claude-autonomous --epic 42          # Focus on Epic #42
#   claude-autonomous --new              # Bootstrap and wait for instructions
#   claude-autonomous --continue         # Resume most recent session
#   claude-autonomous --resume           # Open Claude's session picker
#   claude-autonomous --list             # Show worktree history
#   WORK_EPIC=10 claude-autonomous       # Focus on Epic #10
#
# Documentation: https://github.com/troykelly/claude-skills

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Defaults
REPO_PATH=""
EPIC=""
NEW_MODE=false
CONTINUE_MODE=false
RESUME_SESSION=""
SESSION_LOG="/tmp/claude-sessions.txt"

# Note: Session resume uses Claude's native --continue and --resume flags
# Our session log is for reference only (worktree tracking)

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    -e|--epic)
      if [[ -z "${2:-}" || "$2" == -* ]]; then
        echo -e "${RED}Error: --epic requires a value${NC}"
        exit 1
      fi
      EPIC="$2"
      shift 2
      ;;
    -n|--new)
      NEW_MODE=true
      shift
      ;;
    -c|--continue)
      CONTINUE_MODE=true
      shift
      ;;
    --resume)
      # Check if next arg is a session ID (not another flag)
      if [[ -n "${2:-}" && "$2" != -* ]]; then
        RESUME_SESSION="$2"
        shift 2
      else
        # No ID provided - interactive selection mode
        RESUME_SESSION="INTERACTIVE"
        shift
      fi
      ;;
    -l|--list)
      echo -e "${CYAN}Worktree Session History:${NC}"
      echo ""
      if [[ -f "$SESSION_LOG" ]]; then
        # Format: timestamp session_id repo_name worktree_path details
        echo -e "  ${BLUE}SESSION ID                            REPO           STATUS      DETAILS${NC}"
        echo -e "  ─────────────────────────────────────────────────────────────────────────────────────"
        tail -20 "$SESSION_LOG" | tac | while read -r line; do
          sid=$(echo "$line" | awk '{print $2}')
          repo=$(echo "$line" | awk '{print $3}')
          worktree=$(echo "$line" | awk '{print $4}')
          details=$(echo "$line" | cut -d' ' -f5-)

          # Check if Claude session file exists
          # Worktree path like /tmp/claude-worktrees/repo/uuid -> encoded as -tmp-claude-worktrees-repo-uuid
          encoded_path=$(echo "$worktree" | sed 's|/|-|g')
          session_file="${HOME}/.claude/projects/${encoded_path}/${sid}.jsonl"

          if [[ -f "$session_file" ]]; then
            status="${GREEN}resumable${NC}"
          else
            status="${RED}no session${NC}"
          fi

          printf "  %-37s %-14s ${status}  %s\n" "$sid" "$repo" "$details"
        done
      else
        echo "  No sessions recorded yet."
      fi
      echo ""
      echo -e "${YELLOW}To resume a session:${NC}"
      echo ""
      echo -e "  Most recent session:  ${CYAN}claude-autonomous --continue${NC}"
      echo -e "  Session picker:       ${CYAN}claude-autonomous --resume${NC}"
      echo -e "  Specific session:     ${CYAN}claude-autonomous --resume <session-id>${NC}"
      echo ""
      echo -e "${YELLOW}Note:${NC} Sessions marked '${RED}no session${NC}' have no Claude conversation file"
      echo "      and cannot be resumed (worktree may have been cleaned up before crash)."
      exit 0
      ;;
    -r|--repo)
      if [[ -z "${2:-}" || "$2" == -* ]]; then
        echo -e "${RED}Error: --repo requires a path${NC}"
        exit 1
      fi
      REPO_PATH="$2"
      shift 2
      ;;
    -h|--help)
      head -35 "$0" | grep -E "^#" | sed 's/^# *//'
      exit 0
      ;;
    *)
      echo -e "${RED}Unknown option: $1${NC}"
      echo "Use --help for usage information"
      exit 1
      ;;
  esac
done

# Use WORK_EPIC env var if --epic not provided
EPIC="${EPIC:-${WORK_EPIC:-}}"

# Session log format: timestamp session_id repo_name worktree_path details
# Example: 2026-01-03T12:00:00+00:00 abc-123 my-repo /tmp/claude-worktrees/my-repo/abc-123 epic=#42 "Title"

# Helper: get session info from log by session ID
get_session_info() {
  local session_id="$1"
  if [[ -f "$SESSION_LOG" ]]; then
    grep " ${session_id} " "$SESSION_LOG" | tail -1
  fi
}

# Helper: get most recent session line from log
get_latest_session() {
  if [[ -f "$SESSION_LOG" ]]; then
    tail -1 "$SESSION_LOG"
  fi
}

# Crash recovery loop - wraps claude invocations with auto-restart
# Usage: run_with_crash_recovery <session_id> [initial_prompt]
# If initial_prompt is provided, starts new session; otherwise resumes
run_with_crash_recovery() {
  local sid="$1"
  local initial_prompt="${2:-}"
  local max_crashes="${MAX_CRASHES:-10}"
  local crash_times=()
  local crash_window=60
  local crash_threshold=3
  local total_crashes=0
  local first_run=true
  local msg=""

  echo -e "${GREEN}Starting with crash recovery...${NC}"
  echo ""

  while true; do
    local exit_code=0
    if [[ "$first_run" == "true" ]]; then
      first_run=false
      if [[ -n "$initial_prompt" ]]; then
        claude --dangerously-skip-permissions --session-id "${sid}" "${initial_prompt}" || exit_code=$?
      else
        claude --dangerously-skip-permissions --resume "${sid}" || exit_code=$?
      fi
    else
      claude --dangerously-skip-permissions --resume "${sid}" "$msg" || exit_code=$?
    fi

    # Exit code 0 means successful completion
    if [[ $exit_code -eq 0 ]]; then
      echo -e "${GREEN}Session completed successfully${NC}"
      return 0
    fi

    # Any non-zero exit triggers recovery
    local now
    now=$(date +%s)
    crash_times+=("$now")
    total_crashes=$((total_crashes + 1))

    echo -e "${YELLOW}Claude exited with code ${exit_code}${NC}"

    # Check max crash limit
    if (( total_crashes >= max_crashes )); then
      echo -e "${RED}Maximum crash limit reached (${total_crashes}/${max_crashes})${NC}"
      echo -e "${RED}Session ${sid} terminated due to excessive crashes${NC}"
      echo "Review logs and session state before retrying."
      return 1
    fi

    # Count recent crashes (for loop detection)
    local recent_crashes=0
    for t in "${crash_times[@]}"; do
      if (( now - t < crash_window )); then
        recent_crashes=$((recent_crashes + 1))
      fi
    done

    if (( recent_crashes >= crash_threshold )); then
      echo -e "${RED}⚠️  Rapid crash loop detected ($recent_crashes crashes in ${crash_window}s)${NC}"
      msg="CRITICAL: You have crashed $recent_crashes times in the last ${crash_window} seconds. This indicates a crash loop - something you are repeatedly doing is causing you to crash (likely OOM from large test output, or a runaway process). STOP and think carefully: What were you doing? Do NOT repeat the same action. Consider: 1) Running smaller test subsets, 2) Adding output limits, 3) Taking a different approach entirely. Explain your analysis before proceeding."
      sleep 10
    else
      echo -e "${YELLOW}Restarting after crash... (Session: ${sid}, crash ${total_crashes}/${max_crashes})${NC}"
      msg="You crashed or ran out of memory. This happens occasionally - continue where you left off autonomously."
      sleep 3
    fi
  done
}

# Handle --continue mode (resume most recent session)
if [[ "$CONTINUE_MODE" == "true" ]]; then
  # Check claude is available
  if ! command -v claude &>/dev/null; then
    echo -e "${RED}Error: claude CLI not found${NC}"
    exit 1
  fi

  LATEST=$(get_latest_session)
  if [[ -z "$LATEST" ]]; then
    echo -e "${YELLOW}No sessions in our log. Using Claude's native --continue with crash recovery...${NC}"
    echo ""
    # Simple crash recovery for native --continue (no session ID available)
    max_crashes="${MAX_CRASHES:-10}"
    total_crashes=0
    while true; do
      exit_code=0
      claude --dangerously-skip-permissions --continue || exit_code=$?
      if [[ $exit_code -eq 0 ]]; then
        echo -e "${GREEN}Session completed successfully${NC}"
        exit 0
      fi
      total_crashes=$((total_crashes + 1))
      if (( total_crashes >= max_crashes )); then
        echo -e "${RED}Maximum crash limit reached (${total_crashes}/${max_crashes})${NC}"
        exit 1
      fi
      echo -e "${YELLOW}Claude exited with code ${exit_code}. Restarting... (crash ${total_crashes}/${max_crashes})${NC}"
      sleep 3
    done
  fi

  # Parse session info: timestamp session_id repo_name worktree_path details
  SESSION_ID=$(echo "$LATEST" | awk '{print $2}')
  SESSION_REPO=$(echo "$LATEST" | awk '{print $3}')
  SESSION_WORKTREE=$(echo "$LATEST" | awk '{print $4}')
  SESSION_DETAILS=$(echo "$LATEST" | cut -d' ' -f5-)

  echo -e "${CYAN}╔══════════════════════════════════════════════════════════════╗${NC}"
  echo -e "${CYAN}║${NC}              ${GREEN}Resuming Most Recent Session${NC}                     ${CYAN}║${NC}"
  echo -e "${CYAN}╚══════════════════════════════════════════════════════════════╝${NC}"
  echo ""
  echo -e "${BLUE}Session ID:${NC}   ${SESSION_ID}"
  echo -e "${BLUE}Repository:${NC}   ${SESSION_REPO}"
  echo -e "${BLUE}Worktree:${NC}     ${SESSION_WORKTREE}"
  echo -e "${BLUE}Details:${NC}      ${SESSION_DETAILS}"
  echo ""

  # Check if Claude session file exists before attempting resume
  encoded_path=$(echo "$SESSION_WORKTREE" | sed 's|/|-|g')
  session_file="${HOME}/.claude/projects/${encoded_path}/${SESSION_ID}.jsonl"

  if [[ ! -f "$session_file" ]]; then
    echo -e "${RED}Error: No Claude session file found${NC}"
    echo ""
    echo -e "Expected: ${session_file}"
    echo ""
    echo "This session cannot be resumed. The conversation was either:"
    echo "  - Never saved (Claude crashed before saving)"
    echo "  - Manually deleted"
    echo "  - Created in a different environment"
    echo ""
    echo "Use 'claude-autonomous --list' to see resumable sessions."
    exit 1
  fi
  echo -e "${GREEN}Session file found${NC}"
  echo ""

  # Check if worktree exists, recreate if not
  if [[ ! -d "$SESSION_WORKTREE" ]]; then
    echo -e "${YELLOW}Worktree no longer exists. Recreating...${NC}"

    # We need to be in a git repo to create worktree
    if ! git rev-parse --show-toplevel &>/dev/null; then
      echo -e "${RED}Error: Not in a git repository${NC}"
      echo "Run this command from within the ${SESSION_REPO} repository"
      exit 1
    fi

    REPO_ROOT=$(git rev-parse --show-toplevel)
    CURRENT_REPO=$(basename "$REPO_ROOT")

    if [[ "$CURRENT_REPO" != "$SESSION_REPO" ]]; then
      echo -e "${YELLOW}Warning:${NC} Current repo (${CURRENT_REPO}) differs from session repo (${SESSION_REPO})"
    fi

    # Detect default branch
    DEFAULT_BRANCH=$(git remote show origin 2>/dev/null | grep 'HEAD branch' | cut -d: -f2 | tr -d ' ' || echo "main")
    if [[ -z "$DEFAULT_BRANCH" ]]; then
      if git rev-parse --verify origin/main &>/dev/null; then
        DEFAULT_BRANCH="main"
      elif git rev-parse --verify origin/master &>/dev/null; then
        DEFAULT_BRANCH="master"
      else
        echo -e "${RED}Error: Could not detect default branch${NC}"
        exit 1
      fi
    fi

    # Prune stale worktrees and fetch
    git worktree prune 2>/dev/null || true
    git fetch origin "${DEFAULT_BRANCH}" 2>/dev/null || true

    # Create parent directory if needed
    mkdir -p "$(dirname "$SESSION_WORKTREE")"

    # Create worktree at the exact same path
    if ! git worktree add "${SESSION_WORKTREE}" "origin/${DEFAULT_BRANCH}" 2>&1; then
      echo -e "${RED}Error: Failed to recreate worktree${NC}"
      echo "Try: git worktree prune && git worktree list"
      exit 1
    fi
    echo -e "${GREEN}Worktree recreated successfully${NC}"
    echo ""
  else
    echo -e "${GREEN}Worktree exists${NC}"
    echo ""
  fi

  # Change to worktree directory and resume
  cd "${SESSION_WORKTREE}" || {
    echo -e "${RED}Error: Cannot access worktree directory${NC}"
    exit 1
  }

  echo -e "${GREEN}Resuming session from worktree...${NC}"
  echo ""
  run_with_crash_recovery "${SESSION_ID}"
  exit $?
fi

# Handle --resume mode (interactive or specific session)
if [[ -n "$RESUME_SESSION" ]]; then
  # Check claude is available
  if ! command -v claude &>/dev/null; then
    echo -e "${RED}Error: claude CLI not found${NC}"
    exit 1
  fi

  echo -e "${CYAN}╔══════════════════════════════════════════════════════════════╗${NC}"
  echo -e "${CYAN}║${NC}              ${GREEN}Session Resume${NC}                                   ${CYAN}║${NC}"
  echo -e "${CYAN}╚══════════════════════════════════════════════════════════════╝${NC}"
  echo ""

  if [[ "$RESUME_SESSION" == "INTERACTIVE" ]]; then
    # Show our logged sessions for reference
    if [[ -f "$SESSION_LOG" ]]; then
      echo -e "${BLUE}Recent autonomous sessions from this script:${NC}"
      echo ""
      # Format: timestamp session_id repo_name worktree_path details
      tail -10 "$SESSION_LOG" | tac | while read -r line; do
        sid=$(echo "$line" | awk '{print $2}')
        repo=$(echo "$line" | awk '{print $3}')
        details=$(echo "$line" | cut -d' ' -f5-)
        echo -e "  ${CYAN}${sid:0:8}...${NC}  $repo  $details"
      done
      echo ""
    fi

    echo -e "${BLUE}Opening Claude's session picker...${NC}"
    echo ""
    echo -e "${YELLOW}Tip:${NC} Use ↑/↓ to navigate, Enter to select, P to preview"
    echo -e "     Press A to toggle between current directory and all projects"
    echo ""
    # Use Claude's native --resume for interactive picker with crash recovery
    # After selection, if Claude crashes, --continue resumes the most recent session
    max_crashes="${MAX_CRASHES:-10}"
    total_crashes=0
    first_run=true
    while true; do
      exit_code=0
      if [[ "$first_run" == "true" ]]; then
        first_run=false
        claude --dangerously-skip-permissions --resume || exit_code=$?
      else
        # After first run, use --continue to resume the session they selected
        claude --dangerously-skip-permissions --continue || exit_code=$?
      fi
      if [[ $exit_code -eq 0 ]]; then
        echo -e "${GREEN}Session completed successfully${NC}"
        exit 0
      fi
      total_crashes=$((total_crashes + 1))
      if (( total_crashes >= max_crashes )); then
        echo -e "${RED}Maximum crash limit reached (${total_crashes}/${max_crashes})${NC}"
        exit 1
      fi
      echo -e "${YELLOW}Claude exited with code ${exit_code}. Restarting... (crash ${total_crashes}/${max_crashes})${NC}"
      sleep 3
    done
  else
    # Specific session ID provided - look up worktree path and recreate if needed
    SESSION_INFO=$(get_session_info "$RESUME_SESSION")
    if [[ -n "$SESSION_INFO" ]]; then
      # Format: timestamp session_id repo_name worktree_path details
      SESSION_REPO=$(echo "$SESSION_INFO" | awk '{print $3}')
      SESSION_WORKTREE=$(echo "$SESSION_INFO" | awk '{print $4}')
      SESSION_DETAILS=$(echo "$SESSION_INFO" | cut -d' ' -f5-)

      echo -e "${BLUE}Session ID:${NC}   ${RESUME_SESSION}"
      echo -e "${BLUE}Repository:${NC}   ${SESSION_REPO}"
      echo -e "${BLUE}Worktree:${NC}     ${SESSION_WORKTREE}"
      echo -e "${BLUE}Details:${NC}      ${SESSION_DETAILS}"
      echo ""

      # Check if Claude session file exists before attempting resume
      encoded_path=$(echo "$SESSION_WORKTREE" | sed 's|/|-|g')
      session_file="${HOME}/.claude/projects/${encoded_path}/${RESUME_SESSION}.jsonl"

      if [[ ! -f "$session_file" ]]; then
        echo -e "${RED}Error: No Claude session file found${NC}"
        echo ""
        echo -e "Expected: ${session_file}"
        echo ""
        echo "This session cannot be resumed. The conversation was either:"
        echo "  - Never saved (Claude crashed before saving)"
        echo "  - Manually deleted"
        echo "  - Created in a different environment"
        exit 1
      fi
      echo -e "${GREEN}Session file found${NC}"
      echo ""

      # Check if worktree exists, recreate if not
      if [[ ! -d "$SESSION_WORKTREE" ]]; then
        echo -e "${YELLOW}Worktree no longer exists. Recreating...${NC}"

        # We need to be in a git repo to create worktree
        if ! git rev-parse --show-toplevel &>/dev/null; then
          echo -e "${RED}Error: Not in a git repository${NC}"
          echo "Run this command from within the ${SESSION_REPO} repository"
          exit 1
        fi

        REPO_ROOT=$(git rev-parse --show-toplevel)
        CURRENT_REPO=$(basename "$REPO_ROOT")

        if [[ "$CURRENT_REPO" != "$SESSION_REPO" ]]; then
          echo -e "${YELLOW}Warning:${NC} Current repo (${CURRENT_REPO}) differs from session repo (${SESSION_REPO})"
        fi

        # Detect default branch
        DEFAULT_BRANCH=$(git remote show origin 2>/dev/null | grep 'HEAD branch' | cut -d: -f2 | tr -d ' ' || echo "main")
        if [[ -z "$DEFAULT_BRANCH" ]]; then
          if git rev-parse --verify origin/main &>/dev/null; then
            DEFAULT_BRANCH="main"
          elif git rev-parse --verify origin/master &>/dev/null; then
            DEFAULT_BRANCH="master"
          else
            echo -e "${RED}Error: Could not detect default branch${NC}"
            exit 1
          fi
        fi

        # Prune stale worktrees and fetch
        git worktree prune 2>/dev/null || true
        git fetch origin "${DEFAULT_BRANCH}" 2>/dev/null || true

        # Create parent directory if needed
        mkdir -p "$(dirname "$SESSION_WORKTREE")"

        # Create worktree at the exact same path
        if ! git worktree add "${SESSION_WORKTREE}" "origin/${DEFAULT_BRANCH}" 2>&1; then
          echo -e "${RED}Error: Failed to recreate worktree${NC}"
          echo "Try: git worktree prune && git worktree list"
          exit 1
        fi
        echo -e "${GREEN}Worktree recreated successfully${NC}"
        echo ""
      else
        echo -e "${GREEN}Worktree exists${NC}"
        echo ""
      fi

      # Change to worktree directory and resume
      cd "${SESSION_WORKTREE}" || {
        echo -e "${RED}Error: Cannot access worktree directory${NC}"
        exit 1
      }

      echo -e "${GREEN}Resuming session from worktree...${NC}"
      echo ""
      run_with_crash_recovery "${RESUME_SESSION}"
      exit $?
    else
      echo -e "${BLUE}Session ID:${NC}   ${RESUME_SESSION}"
      echo -e "${YELLOW}Note:${NC} Session not found in our log (may be a Claude-native session)"
      echo ""
      echo -e "${GREEN}Attempting resume...${NC}"
      echo ""
      # No worktree info available, so run from current directory
      run_with_crash_recovery "${RESUME_SESSION}"
      exit $?
    fi
  fi
fi

# Change to repo if specified
if [[ -n "$REPO_PATH" ]]; then
  if [[ ! -d "$REPO_PATH" ]]; then
    echo -e "${RED}Error: Directory does not exist: ${REPO_PATH}${NC}"
    exit 1
  fi
  cd "$REPO_PATH" || {
    echo -e "${RED}Error: Cannot access directory: ${REPO_PATH}${NC}"
    exit 1
  }
fi

# Verify we're in a git repository
if ! git rev-parse --show-toplevel &>/dev/null; then
  echo -e "${RED}Error: Not in a git repository${NC}"
  echo "Run this command from within a git repository, or use --repo <path>"
  exit 1
fi

# Verify origin remote exists
if ! git remote get-url origin &>/dev/null; then
  echo -e "${RED}Error: No 'origin' remote configured${NC}"
  echo "Add a remote with: git remote add origin <url>"
  exit 1
fi

# Check for required tools
check_tool() {
  if ! command -v "$1" &>/dev/null; then
    echo -e "${RED}Error: $1 is required but not installed${NC}"
    echo "Install with: $2"
    exit 1
  fi
}

check_tool "git" "apt-get install git / brew install git"
check_tool "gh" "https://cli.github.com/"
check_tool "claude" "curl -fsSL https://console.anthropic.com/install.sh | sh"
check_tool "jq" "apt-get install jq / brew install jq"

# Check git version supports worktrees (added in git 2.5)
GIT_VERSION=$(git --version | grep -oE '[0-9]+\.[0-9]+' | head -1)
GIT_MAJOR=$(echo "$GIT_VERSION" | cut -d. -f1)
GIT_MINOR=$(echo "$GIT_VERSION" | cut -d. -f2)
if [[ "$GIT_MAJOR" -lt 2 ]] || [[ "$GIT_MAJOR" -eq 2 && "$GIT_MINOR" -lt 5 ]]; then
  echo -e "${RED}Error: git 2.5+ required for worktree support (found: $GIT_VERSION)${NC}"
  exit 1
fi

# Verify gh is authenticated
if ! gh auth status &>/dev/null; then
  echo -e "${RED}Error: GitHub CLI not authenticated${NC}"
  echo "Run: gh auth login"
  exit 1
fi

# Ensure GITHUB_TOKEN is set for MCP servers
if [[ -z "${GITHUB_TOKEN:-}" ]]; then
  echo -e "${YELLOW}GITHUB_TOKEN not set, fetching from gh CLI...${NC}"
  if GH_TOKEN=$(gh auth token 2>/dev/null); then
    export GITHUB_TOKEN="$GH_TOKEN"
    echo -e "${GREEN}GITHUB_TOKEN set from gh auth token${NC}"
  else
    echo -e "${RED}Error: Could not fetch GitHub token from gh CLI${NC}"
    echo "Ensure gh is authenticated with: gh auth login"
    exit 1
  fi
else
  echo -e "${GREEN}GITHUB_TOKEN already set${NC}"
fi

# Validate epic issue exists and is open (if specified)
if [[ -n "$EPIC" ]]; then
  echo -e "${YELLOW}Validating Epic #${EPIC}...${NC}"

  # Fetch issue details
  ISSUE_JSON=$(gh issue view "$EPIC" --json state,title,url 2>/dev/null) || {
    echo -e "${RED}Error: Epic #${EPIC} not found in this repository${NC}"
    echo ""
    echo "Verify the issue number exists: gh issue list"
    exit 1
  }

  ISSUE_STATE=$(echo "$ISSUE_JSON" | jq -r '.state')
  ISSUE_TITLE=$(echo "$ISSUE_JSON" | jq -r '.title')
  ISSUE_URL=$(echo "$ISSUE_JSON" | jq -r '.url')

  if [[ "$ISSUE_STATE" != "OPEN" ]]; then
    echo -e "${RED}Error: Epic #${EPIC} is ${ISSUE_STATE}${NC}"
    echo ""
    echo -e "Title: ${ISSUE_TITLE}"
    echo -e "URL:   ${CYAN}${ISSUE_URL}${NC}"
    echo ""
    echo "Reopen the issue if you want to work on it, then retry."
    exit 1
  fi

  echo -e "${GREEN}Epic #${EPIC} validated: ${ISSUE_TITLE}${NC}"
fi

# Generate session ID (date +%s%N is GNU-only, use $RANDOM for macOS fallback)
SESSION_ID=$(uuidgen 2>/dev/null || cat /proc/sys/kernel/random/uuid 2>/dev/null || echo "$(date +%s)-${RANDOM}-${RANDOM}")
REPO_ROOT=$(git rev-parse --show-toplevel)
REPO_NAME=$(basename "${REPO_ROOT}")
WORKTREE_DIR="/tmp/claude-worktrees/${REPO_NAME}/${SESSION_ID}"
MAX_CRASHES="${MAX_CRASHES:-10}"

# Detect default branch (main, master, or other)
DEFAULT_BRANCH=$(git remote show origin 2>/dev/null | grep 'HEAD branch' | cut -d: -f2 | tr -d ' ' || echo "main")
if [[ -z "$DEFAULT_BRANCH" ]]; then
  # Fallback: check if main or master exists
  if git rev-parse --verify origin/main &>/dev/null; then
    DEFAULT_BRANCH="main"
  elif git rev-parse --verify origin/master &>/dev/null; then
    DEFAULT_BRANCH="master"
  else
    echo -e "${RED}Error: Could not detect default branch${NC}"
    exit 1
  fi
fi

# Clean up stale worktrees from previous runs
echo -e "${YELLOW}Pruning stale worktrees...${NC}"
git worktree prune 2>/dev/null || true

# Log session with restricted permissions
mkdir -p /tmp/claude-worktrees
chmod 700 /tmp/claude-worktrees 2>/dev/null || true
# Log session with worktree path for reference
# Format: timestamp session_id repo_name worktree_path details
if [[ -n "$EPIC" ]]; then
  echo "$(date -Iseconds) ${SESSION_ID} ${REPO_NAME} ${WORKTREE_DIR} epic=#${EPIC} \"${ISSUE_TITLE}\"" >> /tmp/claude-sessions.txt
else
  echo "$(date -Iseconds) ${SESSION_ID} ${REPO_NAME} ${WORKTREE_DIR} scope=all" >> /tmp/claude-sessions.txt
fi
chmod 600 /tmp/claude-sessions.txt 2>/dev/null || true

echo -e "${CYAN}╔══════════════════════════════════════════════════════════════╗${NC}"
echo -e "${CYAN}║${NC}          ${GREEN}Claude Autonomous Issue-Driven Development${NC}          ${CYAN}║${NC}"
echo -e "${CYAN}╚══════════════════════════════════════════════════════════════╝${NC}"
echo ""
echo -e "${BLUE}Session ID:${NC}   ${SESSION_ID}"
echo -e "${BLUE}Repository:${NC}   ${REPO_NAME}"
echo -e "${BLUE}Branch:${NC}       ${DEFAULT_BRANCH}"
echo -e "${BLUE}Worktree:${NC}     ${WORKTREE_DIR}"
echo -e "${BLUE}GitHub Token:${NC} ${GREEN}✓ Set${NC}"
echo -e "${BLUE}Max Crashes:${NC}  ${MAX_CRASHES}"
if [[ "$NEW_MODE" == "true" ]]; then
  echo -e "${BLUE}Mode:${NC}         ${CYAN}Interactive (waiting for instructions)${NC}"
elif [[ -n "$EPIC" ]]; then
  echo -e "${BLUE}Focus Epic:${NC}   #${EPIC} - ${ISSUE_TITLE}"
  echo -e "${BLUE}Epic URL:${NC}     ${CYAN}${ISSUE_URL}${NC}"
else
  echo -e "${BLUE}Scope:${NC}        All open issues and epics"
fi
echo ""

# Fetch and create worktree
echo -e "${YELLOW}Creating isolated worktree from origin/${DEFAULT_BRANCH}...${NC}"
if ! git fetch origin "${DEFAULT_BRANCH}" 2>&1; then
  echo -e "${RED}Error: Failed to fetch origin/${DEFAULT_BRANCH}${NC}"
  echo "Check your network connection and remote configuration."
  exit 1
fi
if ! git worktree add "${WORKTREE_DIR}" "origin/${DEFAULT_BRANCH}" 2>&1; then
  echo -e "${RED}Error: Failed to create worktree${NC}"
  echo "Try: git worktree prune && git worktree list"
  exit 1
fi
echo -e "${GREEN}Worktree created successfully${NC}"
echo ""

# Cleanup function - ONLY cleans up on successful exit (exit code 0)
# Non-zero exits preserve the worktree to avoid losing uncommitted work
CLEANUP_DONE=false
cleanup() {
  if [[ "$CLEANUP_DONE" == "true" ]]; then
    return 0
  fi
  CLEANUP_DONE=true
  local exit_code=$?
  echo ""

  if [[ $exit_code -eq 0 ]]; then
    echo -e "${YELLOW}Session completed successfully. Cleaning up worktree...${NC}"
    cd "${REPO_ROOT}" 2>/dev/null || true
    git worktree remove --force "${WORKTREE_DIR}" 2>/dev/null || true
    git worktree prune 2>/dev/null || true
    echo -e "${GREEN}Session ${SESSION_ID} ended at $(date -Iseconds)${NC}"
  else
    echo -e "${YELLOW}Session exited with code ${exit_code}. Preserving worktree for recovery.${NC}"
    echo -e "${BLUE}Worktree preserved at:${NC} ${WORKTREE_DIR}"
    echo -e "${BLUE}Resume with:${NC} claude-autonomous --resume ${SESSION_ID}"
    echo ""
    echo -e "${YELLOW}To manually cleanup later:${NC}"
    echo -e "  cd ${REPO_ROOT} && git worktree remove ${WORKTREE_DIR}"
  fi
  exit $exit_code
}

# Handle signals gracefully
trap cleanup EXIT
trap 'echo -e "\n${YELLOW}Received interrupt (Ctrl+C) - shutting down gracefully...${NC}"; exit 130' INT
trap 'echo -e "\n${YELLOW}Received termination signal - shutting down...${NC}"; exit 143' TERM

# Change to worktree
cd "${WORKTREE_DIR}"

# Build initial prompt based on mode
if [[ "$NEW_MODE" == "true" ]]; then
  # Interactive mode: bootstrap and wait for instructions
  INITIAL_PROMPT="You are working in an isolated git worktree at: ${WORKTREE_DIR}

This worktree was created from origin/${DEFAULT_BRANCH} to allow autonomous work without affecting the main repository. Your session ID is ${SESSION_ID}.

ENVIRONMENT SETUP:
- Isolated worktree from origin/${DEFAULT_BRANCH}
- GitHub token configured for API access
- Full autonomous permissions enabled
- Crash recovery with session resumption

WORKFLOW CAPABILITIES:
- Create feature branches for work and push to origin
- Create GitHub issues to track work
- Open PRs when work is complete (do not merge directly to ${DEFAULT_BRANCH})
- Use issue-driven development skills for structured work
- Run tests, builds, and verification

READY FOR INSTRUCTIONS:
I am bootstrapped and ready. Please provide your instructions - for example:
- 'Here is a list of bugs in bugs.txt - create issues for each and resolve them'
- 'Implement the features described in FEATURES.md'
- 'Review and fix all TypeScript errors in the codebase'

What would you like me to work on?"
else
  # Standard autonomous mode
  if [[ -n "$EPIC" ]]; then
    EPIC_INSTRUCTION="Focus exclusively on Epic #${EPIC} and its child issues. Do not work on unrelated issues."
  else
    EPIC_INSTRUCTION="Work through all open epics and issues in priority order."
  fi

  INITIAL_PROMPT="You are working in an isolated git worktree at: ${WORKTREE_DIR}

This worktree was created from origin/${DEFAULT_BRANCH} to allow multiple agents to work in parallel without conflicts. Your session ID is ${SESSION_ID}.

IMPORTANT WORKFLOW NOTES:
- You have your own isolated copy of the codebase - other agents may be working in parallel
- Create feature branches for your work and push them to origin
- Open PRs when work is complete - do not merge directly to ${DEFAULT_BRANCH}
- If you need latest changes from ${DEFAULT_BRANCH}, you can pull origin/${DEFAULT_BRANCH} into your worktree

TASK: Use your issue driven development skill to work wholly autonomously until all assigned work is complete.

${EPIC_INSTRUCTION}"
fi

# Crash tracking
CRASH_TIMES=()
CRASH_WINDOW=60
CRASH_THRESHOLD=3
TOTAL_CRASHES=0
FIRST_RUN=true

echo -e "${GREEN}Starting autonomous operation...${NC}"
echo ""

# Run Claude with crash recovery loop
while true; do
  # Capture exit code without triggering set -e
  EXIT_CODE=0
  if [[ "$FIRST_RUN" == "true" ]]; then
    FIRST_RUN=false
    claude --dangerously-skip-permissions --session-id "${SESSION_ID}" "${INITIAL_PROMPT}" || EXIT_CODE=$?
  else
    claude --dangerously-skip-permissions --resume "${SESSION_ID}" "$MSG" || EXIT_CODE=$?
  fi

  # Exit code 0 means successful completion (user quit or work finished)
  if [[ $EXIT_CODE -eq 0 ]]; then
    echo -e "${GREEN}Session completed successfully${NC}"
    break
  fi

  # Any non-zero exit (crash, OOM, killed) triggers recovery
  NOW=$(date +%s)
  CRASH_TIMES+=("$NOW")
  TOTAL_CRASHES=$((TOTAL_CRASHES + 1))

  echo -e "${YELLOW}Claude exited with code ${EXIT_CODE}${NC}"

  # Check max crash limit
  if (( TOTAL_CRASHES >= MAX_CRASHES )); then
    echo -e "${RED}Maximum crash limit reached (${TOTAL_CRASHES}/${MAX_CRASHES})${NC}"
    echo -e "${RED}Session ${SESSION_ID} terminated due to excessive crashes${NC}"
    echo "Review logs and session state before retrying."
    exit 1
  fi

  # Count recent crashes (for loop detection)
  RECENT_CRASHES=0
  for T in "${CRASH_TIMES[@]}"; do
    if (( NOW - T < CRASH_WINDOW )); then
      RECENT_CRASHES=$((RECENT_CRASHES + 1))
    fi
  done

  if (( RECENT_CRASHES >= CRASH_THRESHOLD )); then
    echo -e "${RED}⚠️  Rapid crash loop detected ($RECENT_CRASHES crashes in ${CRASH_WINDOW}s)${NC}"
    MSG="CRITICAL: You have crashed $RECENT_CRASHES times in the last ${CRASH_WINDOW} seconds. This indicates a crash loop - something you are repeatedly doing is causing you to crash (likely OOM from large test output, or a runaway process). STOP and think carefully: What were you doing? Do NOT repeat the same action. Consider: 1) Running smaller test subsets, 2) Adding output limits, 3) Taking a different approach entirely. Explain your analysis before proceeding."
    sleep 10
  else
    echo -e "${YELLOW}Restarting after crash... (Session: ${SESSION_ID}, crash ${TOTAL_CRASHES}/${MAX_CRASHES})${NC}"
    MSG="You crashed or ran out of memory. This happens occasionally - continue where you left off autonomously."
    sleep 3
  fi
done
