#!/usr/bin/env bash
#
# claude-autonomous - Start autonomous issue-driven development with Claude
#
# Usage:
#   claude-autonomous [OPTIONS]
#
# Options:
#   -e, --epic <N>       Focus on specific epic number
#   -n, --new            Interactive mode: bootstrap and wait for instructions
#   -r, --repo <path>    Repository path (default: current directory)
#   -h, --help           Show this help message
#
# Environment Variables:
#   WORK_EPIC            Same as --epic
#   GITHUB_TOKEN         GitHub token for MCP servers (auto-fetched from gh if not set)
#   MAX_CRASHES          Maximum crashes before giving up (default: 10)
#
# Note: Uses claude-opus-4-5-20251101 (Opus 4.5) as the default model
#
# Examples:
#   claude-autonomous                    # Work on all issues
#   claude-autonomous --epic 42          # Focus on Epic #42
#   claude-autonomous --new              # Bootstrap and wait for instructions
#   WORK_EPIC=10 claude-autonomous       # Focus on Epic #10
#
# Documentation: https://github.com/troykelly/claude-skills

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Defaults
REPO_PATH=""
EPIC=""
NEW_MODE=false

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    -e|--epic)
      EPIC="$2"
      shift 2
      ;;
    -n|--new)
      NEW_MODE=true
      shift
      ;;
    -r|--repo)
      REPO_PATH="$2"
      shift 2
      ;;
    -h|--help)
      head -30 "$0" | grep -E "^#" | sed 's/^# *//'
      exit 0
      ;;
    *)
      echo -e "${RED}Unknown option: $1${NC}"
      echo "Use --help for usage information"
      exit 1
      ;;
  esac
done

# Use WORK_EPIC env var if --epic not provided
EPIC="${EPIC:-${WORK_EPIC:-}}"

# Change to repo if specified
if [[ -n "$REPO_PATH" ]]; then
  cd "$REPO_PATH"
fi

# Verify we're in a git repository
if ! git rev-parse --show-toplevel &>/dev/null; then
  echo -e "${RED}Error: Not in a git repository${NC}"
  echo "Run this command from within a git repository, or use --repo <path>"
  exit 1
fi

# Check for required tools
check_tool() {
  if ! command -v "$1" &>/dev/null; then
    echo -e "${RED}Error: $1 is required but not installed${NC}"
    echo "Install with: $2"
    exit 1
  fi
}

check_tool "git" "apt-get install git / brew install git"
check_tool "gh" "https://cli.github.com/"
check_tool "claude" "curl -fsSL https://console.anthropic.com/install.sh | sh"
check_tool "jq" "apt-get install jq / brew install jq"

# Check git version supports worktrees (added in git 2.5)
GIT_VERSION=$(git --version | grep -oE '[0-9]+\.[0-9]+' | head -1)
GIT_MAJOR=$(echo "$GIT_VERSION" | cut -d. -f1)
GIT_MINOR=$(echo "$GIT_VERSION" | cut -d. -f2)
if [[ "$GIT_MAJOR" -lt 2 ]] || [[ "$GIT_MAJOR" -eq 2 && "$GIT_MINOR" -lt 5 ]]; then
  echo -e "${RED}Error: git 2.5+ required for worktree support (found: $GIT_VERSION)${NC}"
  exit 1
fi

# Verify gh is authenticated
if ! gh auth status &>/dev/null; then
  echo -e "${RED}Error: GitHub CLI not authenticated${NC}"
  echo "Run: gh auth login"
  exit 1
fi

# Ensure GITHUB_TOKEN is set for MCP servers
if [[ -z "${GITHUB_TOKEN:-}" ]]; then
  echo -e "${YELLOW}GITHUB_TOKEN not set, fetching from gh CLI...${NC}"
  if GH_TOKEN=$(gh auth token 2>/dev/null); then
    export GITHUB_TOKEN="$GH_TOKEN"
    echo -e "${GREEN}GITHUB_TOKEN set from gh auth token${NC}"
  else
    echo -e "${RED}Error: Could not fetch GitHub token from gh CLI${NC}"
    echo "Ensure gh is authenticated with: gh auth login"
    exit 1
  fi
else
  echo -e "${GREEN}GITHUB_TOKEN already set${NC}"
fi

# Generate session ID
SESSION_ID=$(uuidgen 2>/dev/null || cat /proc/sys/kernel/random/uuid 2>/dev/null || date +%s%N)
REPO_ROOT=$(git rev-parse --show-toplevel)
REPO_NAME=$(basename "${REPO_ROOT}")
WORKTREE_DIR="/tmp/claude-worktrees/${REPO_NAME}/${SESSION_ID}"
MAX_CRASHES="${MAX_CRASHES:-10}"

# Detect default branch (main, master, or other)
DEFAULT_BRANCH=$(git remote show origin 2>/dev/null | grep 'HEAD branch' | cut -d: -f2 | tr -d ' ' || echo "main")
if [[ -z "$DEFAULT_BRANCH" ]]; then
  # Fallback: check if main or master exists
  if git rev-parse --verify origin/main &>/dev/null; then
    DEFAULT_BRANCH="main"
  elif git rev-parse --verify origin/master &>/dev/null; then
    DEFAULT_BRANCH="master"
  else
    echo -e "${RED}Error: Could not detect default branch${NC}"
    exit 1
  fi
fi

# Clean up stale worktrees from previous runs
echo -e "${YELLOW}Pruning stale worktrees...${NC}"
git worktree prune 2>/dev/null || true

# Log session with restricted permissions
mkdir -p /tmp/claude-worktrees
chmod 700 /tmp/claude-worktrees 2>/dev/null || true
echo "$(date -Iseconds) ${SESSION_ID} ${REPO_NAME} epic=${EPIC:-all}" >> /tmp/claude-sessions.txt
chmod 600 /tmp/claude-sessions.txt 2>/dev/null || true

echo -e "${CYAN}╔══════════════════════════════════════════════════════════════╗${NC}"
echo -e "${CYAN}║${NC}          ${GREEN}Claude Autonomous Issue-Driven Development${NC}          ${CYAN}║${NC}"
echo -e "${CYAN}╚══════════════════════════════════════════════════════════════╝${NC}"
echo ""
echo -e "${BLUE}Session ID:${NC}   ${SESSION_ID}"
echo -e "${BLUE}Repository:${NC}   ${REPO_NAME}"
echo -e "${BLUE}Branch:${NC}       ${DEFAULT_BRANCH}"
echo -e "${BLUE}Worktree:${NC}     ${WORKTREE_DIR}"
echo -e "${BLUE}GitHub Token:${NC} ${GREEN}✓ Set${NC}"
echo -e "${BLUE}Max Crashes:${NC}  ${MAX_CRASHES}"
if [[ "$NEW_MODE" == "true" ]]; then
  echo -e "${BLUE}Mode:${NC}         ${CYAN}Interactive (waiting for instructions)${NC}"
elif [[ -n "$EPIC" ]]; then
  echo -e "${BLUE}Focus Epic:${NC}   #${EPIC}"
else
  echo -e "${BLUE}Scope:${NC}        All open issues and epics"
fi
echo ""

# Fetch and create worktree
echo -e "${YELLOW}Creating isolated worktree from origin/${DEFAULT_BRANCH}...${NC}"
git fetch origin "${DEFAULT_BRANCH}"
git worktree add "${WORKTREE_DIR}" "origin/${DEFAULT_BRANCH}"

# Cleanup function
cleanup() {
  local exit_code=$?
  echo ""
  echo -e "${YELLOW}Cleaning up worktree ${WORKTREE_DIR}...${NC}"
  cd "${REPO_ROOT}" 2>/dev/null || true
  git worktree remove --force "${WORKTREE_DIR}" 2>/dev/null || true
  git worktree prune 2>/dev/null || true
  echo -e "${GREEN}Session ${SESSION_ID} ended at $(date -Iseconds)${NC}"
  exit $exit_code
}

# Handle signals gracefully
trap cleanup EXIT
trap 'echo -e "\n${YELLOW}Interrupted - cleaning up...${NC}"; cleanup' INT TERM

# Change to worktree
cd "${WORKTREE_DIR}"

# Build initial prompt based on mode
if [[ "$NEW_MODE" == "true" ]]; then
  # Interactive mode: bootstrap and wait for instructions
  INITIAL_PROMPT="You are working in an isolated git worktree at: ${WORKTREE_DIR}

This worktree was created from origin/${DEFAULT_BRANCH} to allow autonomous work without affecting the main repository. Your session ID is ${SESSION_ID}.

ENVIRONMENT SETUP:
- Isolated worktree from origin/${DEFAULT_BRANCH}
- GitHub token configured for API access
- Full autonomous permissions enabled
- Crash recovery with session resumption

WORKFLOW CAPABILITIES:
- Create feature branches for work and push to origin
- Create GitHub issues to track work
- Open PRs when work is complete (do not merge directly to ${DEFAULT_BRANCH})
- Use issue-driven development skills for structured work
- Run tests, builds, and verification

READY FOR INSTRUCTIONS:
I am bootstrapped and ready. Please provide your instructions - for example:
- 'Here is a list of bugs in bugs.txt - create issues for each and resolve them'
- 'Implement the features described in FEATURES.md'
- 'Review and fix all TypeScript errors in the codebase'

What would you like me to work on?"
else
  # Standard autonomous mode
  if [[ -n "$EPIC" ]]; then
    EPIC_INSTRUCTION="Focus exclusively on Epic #${EPIC} and its child issues. Do not work on unrelated issues."
  else
    EPIC_INSTRUCTION="Work through all open epics and issues in priority order."
  fi

  INITIAL_PROMPT="You are working in an isolated git worktree at: ${WORKTREE_DIR}

This worktree was created from origin/${DEFAULT_BRANCH} to allow multiple agents to work in parallel without conflicts. Your session ID is ${SESSION_ID}.

IMPORTANT WORKFLOW NOTES:
- You have your own isolated copy of the codebase - other agents may be working in parallel
- Create feature branches for your work and push them to origin
- Open PRs when work is complete - do not merge directly to ${DEFAULT_BRANCH}
- If you need latest changes from ${DEFAULT_BRANCH}, you can pull origin/${DEFAULT_BRANCH} into your worktree

TASK: Use your issue driven development skill to work wholly autonomously until all assigned work is complete.

${EPIC_INSTRUCTION}"
fi

# Crash tracking
CRASH_TIMES=()
CRASH_WINDOW=60
CRASH_THRESHOLD=3
TOTAL_CRASHES=0
FIRST_RUN=true

echo -e "${GREEN}Starting autonomous operation...${NC}"
echo ""

# Run Claude with crash recovery loop
while true; do
  if [[ "$FIRST_RUN" == "true" ]]; then
    FIRST_RUN=false
    claude --dangerously-skip-permissions --session-id "${SESSION_ID}" "${INITIAL_PROMPT}"
  else
    claude --dangerously-skip-permissions --resume "${SESSION_ID}" "$MSG"
  fi

  EXIT_CODE=$?

  # Exit code 0 means successful completion (user quit or work finished)
  if [[ $EXIT_CODE -eq 0 ]]; then
    echo -e "${GREEN}Session completed successfully${NC}"
    break
  fi

  # Any non-zero exit (crash, OOM, killed) triggers recovery
  NOW=$(date +%s)
  CRASH_TIMES+=("$NOW")
  ((TOTAL_CRASHES++))

  echo -e "${YELLOW}Claude exited with code ${EXIT_CODE}${NC}"

  # Check max crash limit
  if (( TOTAL_CRASHES >= MAX_CRASHES )); then
    echo -e "${RED}Maximum crash limit reached (${TOTAL_CRASHES}/${MAX_CRASHES})${NC}"
    echo -e "${RED}Session ${SESSION_ID} terminated due to excessive crashes${NC}"
    echo "Review logs and session state before retrying."
    exit 1
  fi

  # Count recent crashes (for loop detection)
  RECENT_CRASHES=0
  for T in "${CRASH_TIMES[@]}"; do
    if (( NOW - T < CRASH_WINDOW )); then
      ((RECENT_CRASHES++))
    fi
  done

  if (( RECENT_CRASHES >= CRASH_THRESHOLD )); then
    echo -e "${RED}⚠️  Rapid crash loop detected ($RECENT_CRASHES crashes in ${CRASH_WINDOW}s)${NC}"
    MSG="CRITICAL: You have crashed $RECENT_CRASHES times in the last ${CRASH_WINDOW} seconds. This indicates a crash loop - something you are repeatedly doing is causing you to crash (likely OOM from large test output, or a runaway process). STOP and think carefully: What were you doing? Do NOT repeat the same action. Consider: 1) Running smaller test subsets, 2) Adding output limits, 3) Taking a different approach entirely. Explain your analysis before proceeding."
    sleep 10
  else
    echo -e "${YELLOW}Restarting after crash... (Session: ${SESSION_ID}, crash ${TOTAL_CRASHES}/${MAX_CRASHES})${NC}"
    MSG="You crashed or ran out of memory. This happens occasionally - continue where you left off autonomously."
    sleep 3
  fi
done
