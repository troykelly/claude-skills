#!/usr/bin/env bash
#
# claude-autonomous - Start autonomous issue-driven development with Claude
#
# Usage:
#   claude-autonomous [OPTIONS]
#
# Options:
#   -e, --epic <N>       Focus on specific epic number
#   -n, --new            Interactive mode: bootstrap and wait for instructions
#   -c, --continue       Resume the most recent session (uses Claude's native --continue)
#   --resume [ID]        Resume a session: opens Claude's picker, or resumes specific ID
#   -l, --list           List worktree session history
#   -r, --repo <path>    Repository path (default: current directory)
#   -h, --help           Show this help message
#
# Environment Variables:
#   WORK_EPIC            Same as --epic
#   GITHUB_TOKEN         GitHub token for MCP servers (auto-fetched from gh if not set)
#   MAX_CRASHES          Maximum crashes before giving up (default: 10)
#
# Note: Uses claude-opus-4-5-20251101 (Opus 4.5) as the default model
#
# Examples:
#   claude-autonomous                    # Work on all issues
#   claude-autonomous --epic 42          # Focus on Epic #42
#   claude-autonomous --new              # Bootstrap and wait for instructions
#   claude-autonomous --continue         # Resume most recent session
#   claude-autonomous --resume           # Open Claude's session picker
#   claude-autonomous --list             # Show worktree history
#   WORK_EPIC=10 claude-autonomous       # Focus on Epic #10
#
# Documentation: https://github.com/troykelly/claude-skills

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Defaults
REPO_PATH=""
EPIC=""
NEW_MODE=false
CONTINUE_MODE=false
RESUME_SESSION=""
SESSION_LOG="/tmp/claude-sessions.txt"

# Note: Session resume uses Claude's native --continue and --resume flags
# Our session log is for reference only (worktree tracking)

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    -e|--epic)
      if [[ -z "${2:-}" || "$2" == -* ]]; then
        echo -e "${RED}Error: --epic requires a value${NC}"
        exit 1
      fi
      EPIC="$2"
      shift 2
      ;;
    -n|--new)
      NEW_MODE=true
      shift
      ;;
    -c|--continue)
      CONTINUE_MODE=true
      shift
      ;;
    --resume)
      # Check if next arg is a session ID (not another flag)
      if [[ -n "${2:-}" && "$2" != -* ]]; then
        RESUME_SESSION="$2"
        shift 2
      else
        # No ID provided - interactive selection mode
        RESUME_SESSION="INTERACTIVE"
        shift
      fi
      ;;
    -l|--list)
      echo -e "${CYAN}Worktree Session History:${NC}"
      echo ""
      if [[ -f "$SESSION_LOG" ]]; then
        # Format: timestamp session_id repo_name worktree_path details
        echo -e "  ${BLUE}SESSION ID                            REPO           DETAILS${NC}"
        echo -e "  ─────────────────────────────────────────────────────────────────────────"
        tail -20 "$SESSION_LOG" | tac | while read -r line; do
          sid=$(echo "$line" | awk '{print $2}')
          repo=$(echo "$line" | awk '{print $3}')
          details=$(echo "$line" | cut -d' ' -f5-)
          printf "  %-37s %-14s %s\n" "$sid" "$repo" "$details"
        done
      else
        echo "  No sessions recorded yet."
      fi
      echo ""
      echo -e "${YELLOW}To resume a session:${NC}"
      echo ""
      echo -e "  Most recent session:  ${CYAN}claude-autonomous --continue${NC}"
      echo -e "  Session picker:       ${CYAN}claude-autonomous --resume${NC}"
      echo -e "  Specific session:     ${CYAN}claude-autonomous --resume <session-id>${NC}"
      exit 0
      ;;
    -r|--repo)
      if [[ -z "${2:-}" || "$2" == -* ]]; then
        echo -e "${RED}Error: --repo requires a path${NC}"
        exit 1
      fi
      REPO_PATH="$2"
      shift 2
      ;;
    -h|--help)
      head -35 "$0" | grep -E "^#" | sed 's/^# *//'
      exit 0
      ;;
    *)
      echo -e "${RED}Unknown option: $1${NC}"
      echo "Use --help for usage information"
      exit 1
      ;;
  esac
done

# Use WORK_EPIC env var if --epic not provided
EPIC="${EPIC:-${WORK_EPIC:-}}"

# Session log format: timestamp session_id repo_name worktree_path details
# Example: 2026-01-03T12:00:00+00:00 abc-123 my-repo /tmp/claude-worktrees/my-repo/abc-123 epic=#42 "Title"

# Helper: get session info from log by session ID
get_session_info() {
  local session_id="$1"
  if [[ -f "$SESSION_LOG" ]]; then
    grep " ${session_id} " "$SESSION_LOG" | tail -1
  fi
}

# Helper: get most recent session line from log
get_latest_session() {
  if [[ -f "$SESSION_LOG" ]]; then
    tail -1 "$SESSION_LOG"
  fi
}

# Handle --continue mode (resume most recent session)
if [[ "$CONTINUE_MODE" == "true" ]]; then
  # Check claude is available
  if ! command -v claude &>/dev/null; then
    echo -e "${RED}Error: claude CLI not found${NC}"
    exit 1
  fi

  LATEST=$(get_latest_session)
  if [[ -z "$LATEST" ]]; then
    echo -e "${YELLOW}No sessions in our log. Using Claude's native --continue...${NC}"
    exec claude --dangerously-skip-permissions --continue
  fi

  # Parse session info: timestamp session_id repo_name worktree_path details
  SESSION_ID=$(echo "$LATEST" | awk '{print $2}')
  SESSION_REPO=$(echo "$LATEST" | awk '{print $3}')
  # Note: worktree path is field 4, details start at field 5
  SESSION_DETAILS=$(echo "$LATEST" | cut -d' ' -f5-)

  echo -e "${CYAN}╔══════════════════════════════════════════════════════════════╗${NC}"
  echo -e "${CYAN}║${NC}              ${GREEN}Resuming Most Recent Session${NC}                     ${CYAN}║${NC}"
  echo -e "${CYAN}╚══════════════════════════════════════════════════════════════╝${NC}"
  echo ""
  echo -e "${BLUE}Session ID:${NC}   ${SESSION_ID}"
  echo -e "${BLUE}Repository:${NC}   ${SESSION_REPO}"
  echo -e "${BLUE}Details:${NC}      ${SESSION_DETAILS}"
  echo ""

  # Sessions are directory-scoped. Try to find the repo.
  # First check if we're already in a git repo
  if git rev-parse --show-toplevel &>/dev/null; then
    CURRENT_REPO=$(basename "$(git rev-parse --show-toplevel)")
    if [[ "$CURRENT_REPO" == "$SESSION_REPO" ]]; then
      echo -e "${GREEN}Already in correct repository. Resuming...${NC}"
      echo ""
      exec claude --dangerously-skip-permissions --resume "${SESSION_ID}"
    fi
  fi

  # Not in correct repo - try to find it
  echo -e "${YELLOW}Note:${NC} Sessions are directory-scoped. For best results, run from the ${SESSION_REPO} repository."
  echo ""
  echo -e "${GREEN}Attempting resume with session ID...${NC}"
  echo ""
  exec claude --dangerously-skip-permissions --resume "${SESSION_ID}"
fi

# Handle --resume mode (interactive or specific session)
if [[ -n "$RESUME_SESSION" ]]; then
  # Check claude is available
  if ! command -v claude &>/dev/null; then
    echo -e "${RED}Error: claude CLI not found${NC}"
    exit 1
  fi

  echo -e "${CYAN}╔══════════════════════════════════════════════════════════════╗${NC}"
  echo -e "${CYAN}║${NC}              ${GREEN}Session Resume${NC}                                   ${CYAN}║${NC}"
  echo -e "${CYAN}╚══════════════════════════════════════════════════════════════╝${NC}"
  echo ""

  if [[ "$RESUME_SESSION" == "INTERACTIVE" ]]; then
    # Show our logged sessions for reference
    if [[ -f "$SESSION_LOG" ]]; then
      echo -e "${BLUE}Recent autonomous sessions from this script:${NC}"
      echo ""
      # Format: timestamp session_id repo_name worktree_path details
      tail -10 "$SESSION_LOG" | tac | while read -r line; do
        sid=$(echo "$line" | awk '{print $2}')
        repo=$(echo "$line" | awk '{print $3}')
        details=$(echo "$line" | cut -d' ' -f5-)
        echo -e "  ${CYAN}${sid:0:8}...${NC}  $repo  $details"
      done
      echo ""
    fi

    echo -e "${BLUE}Opening Claude's session picker...${NC}"
    echo ""
    echo -e "${YELLOW}Tip:${NC} Use ↑/↓ to navigate, Enter to select, P to preview"
    echo -e "     Press A to toggle between current directory and all projects"
    echo ""
    # Use Claude's native --resume for interactive picker
    exec claude --dangerously-skip-permissions --resume
  else
    # Specific session ID provided
    SESSION_INFO=$(get_session_info "$RESUME_SESSION")
    if [[ -n "$SESSION_INFO" ]]; then
      # Format: timestamp session_id repo_name worktree_path details
      SESSION_REPO=$(echo "$SESSION_INFO" | awk '{print $3}')
      SESSION_DETAILS=$(echo "$SESSION_INFO" | cut -d' ' -f5-)
      echo -e "${BLUE}Session ID:${NC}   ${RESUME_SESSION}"
      echo -e "${BLUE}Repository:${NC}   ${SESSION_REPO}"
      echo -e "${BLUE}Details:${NC}      ${SESSION_DETAILS}"
      echo ""
    else
      echo -e "${BLUE}Session ID:${NC}   ${RESUME_SESSION}"
      echo -e "${YELLOW}Note:${NC} Session not found in our log (may be a Claude-native session)"
      echo ""
    fi

    echo -e "${GREEN}Resuming session...${NC}"
    echo ""
    exec claude --dangerously-skip-permissions --resume "${RESUME_SESSION}"
  fi
fi

# Change to repo if specified
if [[ -n "$REPO_PATH" ]]; then
  if [[ ! -d "$REPO_PATH" ]]; then
    echo -e "${RED}Error: Directory does not exist: ${REPO_PATH}${NC}"
    exit 1
  fi
  cd "$REPO_PATH" || {
    echo -e "${RED}Error: Cannot access directory: ${REPO_PATH}${NC}"
    exit 1
  }
fi

# Verify we're in a git repository
if ! git rev-parse --show-toplevel &>/dev/null; then
  echo -e "${RED}Error: Not in a git repository${NC}"
  echo "Run this command from within a git repository, or use --repo <path>"
  exit 1
fi

# Verify origin remote exists
if ! git remote get-url origin &>/dev/null; then
  echo -e "${RED}Error: No 'origin' remote configured${NC}"
  echo "Add a remote with: git remote add origin <url>"
  exit 1
fi

# Check for required tools
check_tool() {
  if ! command -v "$1" &>/dev/null; then
    echo -e "${RED}Error: $1 is required but not installed${NC}"
    echo "Install with: $2"
    exit 1
  fi
}

check_tool "git" "apt-get install git / brew install git"
check_tool "gh" "https://cli.github.com/"
check_tool "claude" "curl -fsSL https://console.anthropic.com/install.sh | sh"
check_tool "jq" "apt-get install jq / brew install jq"

# Check git version supports worktrees (added in git 2.5)
GIT_VERSION=$(git --version | grep -oE '[0-9]+\.[0-9]+' | head -1)
GIT_MAJOR=$(echo "$GIT_VERSION" | cut -d. -f1)
GIT_MINOR=$(echo "$GIT_VERSION" | cut -d. -f2)
if [[ "$GIT_MAJOR" -lt 2 ]] || [[ "$GIT_MAJOR" -eq 2 && "$GIT_MINOR" -lt 5 ]]; then
  echo -e "${RED}Error: git 2.5+ required for worktree support (found: $GIT_VERSION)${NC}"
  exit 1
fi

# Verify gh is authenticated
if ! gh auth status &>/dev/null; then
  echo -e "${RED}Error: GitHub CLI not authenticated${NC}"
  echo "Run: gh auth login"
  exit 1
fi

# Ensure GITHUB_TOKEN is set for MCP servers
if [[ -z "${GITHUB_TOKEN:-}" ]]; then
  echo -e "${YELLOW}GITHUB_TOKEN not set, fetching from gh CLI...${NC}"
  if GH_TOKEN=$(gh auth token 2>/dev/null); then
    export GITHUB_TOKEN="$GH_TOKEN"
    echo -e "${GREEN}GITHUB_TOKEN set from gh auth token${NC}"
  else
    echo -e "${RED}Error: Could not fetch GitHub token from gh CLI${NC}"
    echo "Ensure gh is authenticated with: gh auth login"
    exit 1
  fi
else
  echo -e "${GREEN}GITHUB_TOKEN already set${NC}"
fi

# Validate epic issue exists and is open (if specified)
if [[ -n "$EPIC" ]]; then
  echo -e "${YELLOW}Validating Epic #${EPIC}...${NC}"

  # Fetch issue details
  ISSUE_JSON=$(gh issue view "$EPIC" --json state,title,url 2>/dev/null) || {
    echo -e "${RED}Error: Epic #${EPIC} not found in this repository${NC}"
    echo ""
    echo "Verify the issue number exists: gh issue list"
    exit 1
  }

  ISSUE_STATE=$(echo "$ISSUE_JSON" | jq -r '.state')
  ISSUE_TITLE=$(echo "$ISSUE_JSON" | jq -r '.title')
  ISSUE_URL=$(echo "$ISSUE_JSON" | jq -r '.url')

  if [[ "$ISSUE_STATE" != "OPEN" ]]; then
    echo -e "${RED}Error: Epic #${EPIC} is ${ISSUE_STATE}${NC}"
    echo ""
    echo -e "Title: ${ISSUE_TITLE}"
    echo -e "URL:   ${CYAN}${ISSUE_URL}${NC}"
    echo ""
    echo "Reopen the issue if you want to work on it, then retry."
    exit 1
  fi

  echo -e "${GREEN}Epic #${EPIC} validated: ${ISSUE_TITLE}${NC}"
fi

# Generate session ID (date +%s%N is GNU-only, use $RANDOM for macOS fallback)
SESSION_ID=$(uuidgen 2>/dev/null || cat /proc/sys/kernel/random/uuid 2>/dev/null || echo "$(date +%s)-${RANDOM}-${RANDOM}")
REPO_ROOT=$(git rev-parse --show-toplevel)
REPO_NAME=$(basename "${REPO_ROOT}")
WORKTREE_DIR="/tmp/claude-worktrees/${REPO_NAME}/${SESSION_ID}"
MAX_CRASHES="${MAX_CRASHES:-10}"

# Detect default branch (main, master, or other)
DEFAULT_BRANCH=$(git remote show origin 2>/dev/null | grep 'HEAD branch' | cut -d: -f2 | tr -d ' ' || echo "main")
if [[ -z "$DEFAULT_BRANCH" ]]; then
  # Fallback: check if main or master exists
  if git rev-parse --verify origin/main &>/dev/null; then
    DEFAULT_BRANCH="main"
  elif git rev-parse --verify origin/master &>/dev/null; then
    DEFAULT_BRANCH="master"
  else
    echo -e "${RED}Error: Could not detect default branch${NC}"
    exit 1
  fi
fi

# Clean up stale worktrees from previous runs
echo -e "${YELLOW}Pruning stale worktrees...${NC}"
git worktree prune 2>/dev/null || true

# Log session with restricted permissions
mkdir -p /tmp/claude-worktrees
chmod 700 /tmp/claude-worktrees 2>/dev/null || true
# Log session with worktree path for reference
# Format: timestamp session_id repo_name worktree_path details
if [[ -n "$EPIC" ]]; then
  echo "$(date -Iseconds) ${SESSION_ID} ${REPO_NAME} ${WORKTREE_DIR} epic=#${EPIC} \"${ISSUE_TITLE}\"" >> /tmp/claude-sessions.txt
else
  echo "$(date -Iseconds) ${SESSION_ID} ${REPO_NAME} ${WORKTREE_DIR} scope=all" >> /tmp/claude-sessions.txt
fi
chmod 600 /tmp/claude-sessions.txt 2>/dev/null || true

echo -e "${CYAN}╔══════════════════════════════════════════════════════════════╗${NC}"
echo -e "${CYAN}║${NC}          ${GREEN}Claude Autonomous Issue-Driven Development${NC}          ${CYAN}║${NC}"
echo -e "${CYAN}╚══════════════════════════════════════════════════════════════╝${NC}"
echo ""
echo -e "${BLUE}Session ID:${NC}   ${SESSION_ID}"
echo -e "${BLUE}Repository:${NC}   ${REPO_NAME}"
echo -e "${BLUE}Branch:${NC}       ${DEFAULT_BRANCH}"
echo -e "${BLUE}Worktree:${NC}     ${WORKTREE_DIR}"
echo -e "${BLUE}GitHub Token:${NC} ${GREEN}✓ Set${NC}"
echo -e "${BLUE}Max Crashes:${NC}  ${MAX_CRASHES}"
if [[ "$NEW_MODE" == "true" ]]; then
  echo -e "${BLUE}Mode:${NC}         ${CYAN}Interactive (waiting for instructions)${NC}"
elif [[ -n "$EPIC" ]]; then
  echo -e "${BLUE}Focus Epic:${NC}   #${EPIC} - ${ISSUE_TITLE}"
  echo -e "${BLUE}Epic URL:${NC}     ${CYAN}${ISSUE_URL}${NC}"
else
  echo -e "${BLUE}Scope:${NC}        All open issues and epics"
fi
echo ""

# Fetch and create worktree
echo -e "${YELLOW}Creating isolated worktree from origin/${DEFAULT_BRANCH}...${NC}"
if ! git fetch origin "${DEFAULT_BRANCH}" 2>&1; then
  echo -e "${RED}Error: Failed to fetch origin/${DEFAULT_BRANCH}${NC}"
  echo "Check your network connection and remote configuration."
  exit 1
fi
if ! git worktree add "${WORKTREE_DIR}" "origin/${DEFAULT_BRANCH}" 2>&1; then
  echo -e "${RED}Error: Failed to create worktree${NC}"
  echo "Try: git worktree prune && git worktree list"
  exit 1
fi
echo -e "${GREEN}Worktree created successfully${NC}"
echo ""

# Cleanup function (with guard against double-execution from nested traps)
CLEANUP_DONE=false
cleanup() {
  if [[ "$CLEANUP_DONE" == "true" ]]; then
    return 0
  fi
  CLEANUP_DONE=true
  local exit_code=$?
  echo ""
  echo -e "${YELLOW}Cleaning up worktree ${WORKTREE_DIR}...${NC}"
  cd "${REPO_ROOT}" 2>/dev/null || true
  git worktree remove --force "${WORKTREE_DIR}" 2>/dev/null || true
  git worktree prune 2>/dev/null || true
  echo -e "${GREEN}Session ${SESSION_ID} ended at $(date -Iseconds)${NC}"
  exit $exit_code
}

# Handle signals gracefully
trap cleanup EXIT
trap 'echo -e "\n${YELLOW}Received interrupt (Ctrl+C) - shutting down gracefully...${NC}"; exit 130' INT
trap 'echo -e "\n${YELLOW}Received termination signal - shutting down...${NC}"; exit 143' TERM

# Change to worktree
cd "${WORKTREE_DIR}"

# Build initial prompt based on mode
if [[ "$NEW_MODE" == "true" ]]; then
  # Interactive mode: bootstrap and wait for instructions
  INITIAL_PROMPT="You are working in an isolated git worktree at: ${WORKTREE_DIR}

This worktree was created from origin/${DEFAULT_BRANCH} to allow autonomous work without affecting the main repository. Your session ID is ${SESSION_ID}.

ENVIRONMENT SETUP:
- Isolated worktree from origin/${DEFAULT_BRANCH}
- GitHub token configured for API access
- Full autonomous permissions enabled
- Crash recovery with session resumption

WORKFLOW CAPABILITIES:
- Create feature branches for work and push to origin
- Create GitHub issues to track work
- Open PRs when work is complete (do not merge directly to ${DEFAULT_BRANCH})
- Use issue-driven development skills for structured work
- Run tests, builds, and verification

READY FOR INSTRUCTIONS:
I am bootstrapped and ready. Please provide your instructions - for example:
- 'Here is a list of bugs in bugs.txt - create issues for each and resolve them'
- 'Implement the features described in FEATURES.md'
- 'Review and fix all TypeScript errors in the codebase'

What would you like me to work on?"
else
  # Standard autonomous mode
  if [[ -n "$EPIC" ]]; then
    EPIC_INSTRUCTION="Focus exclusively on Epic #${EPIC} and its child issues. Do not work on unrelated issues."
  else
    EPIC_INSTRUCTION="Work through all open epics and issues in priority order."
  fi

  INITIAL_PROMPT="You are working in an isolated git worktree at: ${WORKTREE_DIR}

This worktree was created from origin/${DEFAULT_BRANCH} to allow multiple agents to work in parallel without conflicts. Your session ID is ${SESSION_ID}.

IMPORTANT WORKFLOW NOTES:
- You have your own isolated copy of the codebase - other agents may be working in parallel
- Create feature branches for your work and push them to origin
- Open PRs when work is complete - do not merge directly to ${DEFAULT_BRANCH}
- If you need latest changes from ${DEFAULT_BRANCH}, you can pull origin/${DEFAULT_BRANCH} into your worktree

TASK: Use your issue driven development skill to work wholly autonomously until all assigned work is complete.

${EPIC_INSTRUCTION}"
fi

# Crash tracking
CRASH_TIMES=()
CRASH_WINDOW=60
CRASH_THRESHOLD=3
TOTAL_CRASHES=0
FIRST_RUN=true

echo -e "${GREEN}Starting autonomous operation...${NC}"
echo ""

# Run Claude with crash recovery loop
while true; do
  # Capture exit code without triggering set -e
  EXIT_CODE=0
  if [[ "$FIRST_RUN" == "true" ]]; then
    FIRST_RUN=false
    claude --dangerously-skip-permissions --session-id "${SESSION_ID}" "${INITIAL_PROMPT}" || EXIT_CODE=$?
  else
    claude --dangerously-skip-permissions --resume "${SESSION_ID}" "$MSG" || EXIT_CODE=$?
  fi

  # Exit code 0 means successful completion (user quit or work finished)
  if [[ $EXIT_CODE -eq 0 ]]; then
    echo -e "${GREEN}Session completed successfully${NC}"
    break
  fi

  # Any non-zero exit (crash, OOM, killed) triggers recovery
  NOW=$(date +%s)
  CRASH_TIMES+=("$NOW")
  TOTAL_CRASHES=$((TOTAL_CRASHES + 1))

  echo -e "${YELLOW}Claude exited with code ${EXIT_CODE}${NC}"

  # Check max crash limit
  if (( TOTAL_CRASHES >= MAX_CRASHES )); then
    echo -e "${RED}Maximum crash limit reached (${TOTAL_CRASHES}/${MAX_CRASHES})${NC}"
    echo -e "${RED}Session ${SESSION_ID} terminated due to excessive crashes${NC}"
    echo "Review logs and session state before retrying."
    exit 1
  fi

  # Count recent crashes (for loop detection)
  RECENT_CRASHES=0
  for T in "${CRASH_TIMES[@]}"; do
    if (( NOW - T < CRASH_WINDOW )); then
      RECENT_CRASHES=$((RECENT_CRASHES + 1))
    fi
  done

  if (( RECENT_CRASHES >= CRASH_THRESHOLD )); then
    echo -e "${RED}⚠️  Rapid crash loop detected ($RECENT_CRASHES crashes in ${CRASH_WINDOW}s)${NC}"
    MSG="CRITICAL: You have crashed $RECENT_CRASHES times in the last ${CRASH_WINDOW} seconds. This indicates a crash loop - something you are repeatedly doing is causing you to crash (likely OOM from large test output, or a runaway process). STOP and think carefully: What were you doing? Do NOT repeat the same action. Consider: 1) Running smaller test subsets, 2) Adding output limits, 3) Taking a different approach entirely. Explain your analysis before proceeding."
    sleep 10
  else
    echo -e "${YELLOW}Restarting after crash... (Session: ${SESSION_ID}, crash ${TOTAL_CRASHES}/${MAX_CRASHES})${NC}"
    MSG="You crashed or ran out of memory. This happens occasionally - continue where you left off autonomously."
    sleep 3
  fi
done
