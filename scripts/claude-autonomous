#!/usr/bin/env bash
#
# claude-autonomous - Start autonomous issue-driven development with Claude
#
# Version: 1.9.0 (issue-driven-development plugin)
#
# Usage:
#   claude-autonomous [OPTIONS]
#
# Options:
#   -e, --epic <N>       Focus on specific epic number
#   -p, --pr [N,N,...]   Focus on resolving PRs (comma-separated, or all if omitted)
#   -n, --new            Interactive mode: bootstrap and wait for instructions
#   -c, --continue       Resume the most recent session (uses Claude's native --continue)
#   --resume [ID]        Resume a session: opens Claude's picker, or resumes specific ID
#   -l, --list           List worktree session history
#   -r, --repo <path>    Repository path (default: current directory)
#   -v, --version        Show version information
#   -h, --help           Show this help message
#
# Environment Variables:
#   WORK_EPIC            Same as --epic
#   WORK_PRS             Same as --pr (comma-separated PR numbers)
#   GITHUB_TOKEN         GitHub token for MCP servers (auto-fetched from gh if not set)
#   MAX_CRASHES          Maximum crashes before giving up (default: 10)
#   CLAUDE_ACCOUNT_COOLDOWN_MINUTES  Cooldown after account exhaustion (default: 5)
#   CLAUDE_AUTONOMOUS_MAX_SWITCHES   Max account switches per session (default: 10)
#   CLAUDE_CONFIG_DIR    Claude Code config directory (set by Claude Code in devcontainers)
#   CLAUDE_MODEL         Model to use (default: claude-opus-4-5-20251101)
#
# Note: Uses claude-opus-4-5-20251101 (Opus 4.5) as the default model
#
# Examples:
#   claude-autonomous                    # Work on all issues
#   claude-autonomous --epic 42          # Focus on Epic #42
#   claude-autonomous --pr               # Resolve all open PRs
#   claude-autonomous --pr 123,456       # Resolve specific PRs
#   claude-autonomous --new              # Bootstrap and wait for instructions
#   claude-autonomous --continue         # Resume most recent session
#   claude-autonomous --resume           # Open Claude's session picker
#   claude-autonomous --list             # Show worktree history
#   WORK_EPIC=10 claude-autonomous       # Focus on Epic #10
#   WORK_PRS=123,456 claude-autonomous   # Resolve specific PRs
#
# Documentation: https://github.com/troykelly/claude-skills

set -euo pipefail

# Version - keep in sync with plugin.json
VERSION="1.8.1"

# Model to use for autonomous operations (can be overridden via environment)
CLAUDE_MODEL="${CLAUDE_MODEL:-claude-opus-4-5-20251101}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# Claude Code config directory (respects CLAUDE_CONFIG_DIR environment variable)
# If CLAUDE_CONFIG_DIR is set: projects at $CLAUDE_CONFIG_DIR/projects/
# Otherwise: projects at ~/.claude/projects/
CLAUDE_CONFIG_DIR="${CLAUDE_CONFIG_DIR:-}"
if [[ -n "$CLAUDE_CONFIG_DIR" ]]; then
  CLAUDE_PROJECTS_DIR="${CLAUDE_CONFIG_DIR}/projects"
  CLAUDE_STATE_DIR="${CLAUDE_CONFIG_DIR}"
else
  CLAUDE_PROJECTS_DIR="${HOME}/.claude/projects"
  CLAUDE_STATE_DIR="${HOME}/.claude"
fi

# Multi-account configuration
MAX_ACCOUNT_SWITCHES="${CLAUDE_AUTONOMOUS_MAX_SWITCHES:-10}"
ACCOUNT_SWITCH_COUNT=0

# Find claude-account script
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CLAUDE_ACCOUNT="${SCRIPT_DIR}/claude-account"

# Check if claude-account is available
has_multi_account_support() {
  [[ -x "$CLAUDE_ACCOUNT" ]] || command -v claude-account &>/dev/null
}

# Get claude-account command
get_claude_account_cmd() {
  if [[ -x "$CLAUDE_ACCOUNT" ]]; then
    echo "$CLAUDE_ACCOUNT"
  elif command -v claude-account &>/dev/null; then
    echo "claude-account"
  else
    echo ""
  fi
}

# Check if output indicates plan limit was hit
detect_plan_limit_in_output() {
  local output="$1"
  local patterns=(
    "Plan limit reached"
    "rate.limit"
    "quota.exceeded"
    "usage.limit"
    "capacity.limit"
    "too.many.requests"
    "Switching to account"
    "All accounts exhausted"
    "limit.reached"
    "exceeded.your"
  )

  for pattern in "${patterns[@]}"; do
    if echo "$output" | grep -qiE "$pattern"; then
      return 0
    fi
  done
  return 1
}

# Try to switch to next available account
try_switch_account() {
  local cmd
  cmd=$(get_claude_account_cmd)

  if [[ -z "$cmd" ]]; then
    echo -e "${YELLOW}Multi-account support not available${NC}" >&2
    return 1
  fi

  # Check switch limit
  if [[ $ACCOUNT_SWITCH_COUNT -ge $MAX_ACCOUNT_SWITCHES ]]; then
    echo -e "${RED}Maximum account switches ($MAX_ACCOUNT_SWITCHES) reached${NC}" >&2
    return 1
  fi

  # Get next available account
  local next_account
  if ! next_account=$("$cmd" next 2>/dev/null); then
    echo -e "${YELLOW}No available accounts to switch to${NC}" >&2
    return 1
  fi

  # Mark current as exhausted and switch
  echo -e "${YELLOW}Plan limit detected. Switching accounts...${NC}"
  "$cmd" mark-exhausted 2>/dev/null || true

  if "$cmd" switch "$next_account" 2>/dev/null; then
    ACCOUNT_SWITCH_COUNT=$((ACCOUNT_SWITCH_COUNT + 1))
    echo -e "${GREEN}Switched to: ${next_account}${NC}"
    echo -e "${BLUE}Account switches this session: ${ACCOUNT_SWITCH_COUNT}/${MAX_ACCOUNT_SWITCHES}${NC}"
    return 0
  else
    echo -e "${RED}Failed to switch account${NC}" >&2
    return 1
  fi
}

# Wait for account cooldown
wait_for_account_cooldown() {
  local cmd
  cmd=$(get_claude_account_cmd)
  local cooldown_minutes="${CLAUDE_ACCOUNT_COOLDOWN_MINUTES:-5}"
  local seconds=$((cooldown_minutes * 60))

  echo -e "${YELLOW}All accounts exhausted. Waiting ${cooldown_minutes} minutes for cooldown...${NC}"
  echo ""

  while [[ $seconds -gt 0 ]]; do
    local mins=$((seconds / 60))
    local secs=$((seconds % 60))
    printf "\r${BLUE}Resuming in: %02d:%02d${NC}  " "$mins" "$secs"
    sleep 1
    ((seconds--))
  done

  echo ""
  echo -e "${GREEN}Cooldown complete. Resetting exhaustion statuses...${NC}"

  if [[ -n "$cmd" ]]; then
    "$cmd" reset-exhausted 2>/dev/null || true
  fi

  # Reset switch count after cooldown
  ACCOUNT_SWITCH_COUNT=0
}

# Signal handling: Ignore signals to parent so only Claude (child) receives them
# This allows our crash recovery loops to catch Claude's exit and restart
# The child process still receives and handles signals normally
trap '' SIGTERM SIGINT

# Defaults
REPO_PATH=""
EPIC=""
PRS=""
PR_MODE=false
NEW_MODE=false
CONTINUE_MODE=false
RESUME_SESSION=""
SESSION_LOG="/tmp/claude-sessions.txt"

# Note: Session resume uses Claude's native --continue and --resume flags
# Our session log is for reference only (worktree tracking)

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    -e|--epic)
      if [[ -z "${2:-}" || "$2" == -* ]]; then
        echo -e "${RED}Error: --epic requires a value${NC}"
        exit 1
      fi
      EPIC="$2"
      shift 2
      ;;
    -p|--pr)
      PR_MODE=true
      # Check if next arg is a PR list (not another flag)
      if [[ -n "${2:-}" && "$2" != -* ]]; then
        PRS="$2"
        shift 2
      else
        # No PRs provided - will target all open PRs
        PRS=""
        shift
      fi
      ;;
    -n|--new)
      NEW_MODE=true
      shift
      ;;
    -c|--continue)
      CONTINUE_MODE=true
      shift
      ;;
    --resume)
      # Check if next arg is a session ID (not another flag)
      if [[ -n "${2:-}" && "$2" != -* ]]; then
        RESUME_SESSION="$2"
        shift 2
      else
        # No ID provided - interactive selection mode
        RESUME_SESSION="INTERACTIVE"
        shift
      fi
      ;;
    -l|--list)
      echo -e "${CYAN}Worktree Session History:${NC}"
      echo ""
      if [[ -f "$SESSION_LOG" ]]; then
        # Format: timestamp session_id repo_name worktree_path details
        echo -e "  ${BLUE}SESSION ID                            REPO           STATUS      DETAILS${NC}"
        echo -e "  ─────────────────────────────────────────────────────────────────────────────────────"
        tail -20 "$SESSION_LOG" | tac | while read -r line; do
          sid=$(echo "$line" | awk '{print $2}')
          repo=$(echo "$line" | awk '{print $3}')
          worktree=$(echo "$line" | awk '{print $4}')
          details=$(echo "$line" | cut -d' ' -f5-)

          # Check if Claude session file exists
          # Worktree path like /tmp/claude-worktrees/repo/uuid -> encoded as -tmp-claude-worktrees-repo-uuid
          encoded_path=$(echo "$worktree" | sed 's|/|-|g')
          session_file="${CLAUDE_PROJECTS_DIR}/${encoded_path}/${sid}.jsonl"

          if [[ -f "$session_file" ]]; then
            status="${GREEN}resumable${NC}"
          else
            status="${RED}no session${NC}"
          fi

          printf "  %-37s %-14s ${status}  %s\n" "$sid" "$repo" "$details"
        done
      else
        echo "  No sessions recorded yet."
      fi
      echo ""
      echo -e "${YELLOW}To resume a session:${NC}"
      echo ""
      echo -e "  Most recent session:  ${CYAN}claude-autonomous --continue${NC}"
      echo -e "  Session picker:       ${CYAN}claude-autonomous --resume${NC}"
      echo -e "  Specific session:     ${CYAN}claude-autonomous --resume <session-id>${NC}"
      echo ""
      echo -e "${YELLOW}Note:${NC} Sessions marked '${RED}no session${NC}' have no Claude conversation file"
      echo "      and cannot be resumed (worktree may have been cleaned up before crash)."
      exit 0
      ;;
    -r|--repo)
      if [[ -z "${2:-}" || "$2" == -* ]]; then
        echo -e "${RED}Error: --repo requires a path${NC}"
        exit 1
      fi
      REPO_PATH="$2"
      shift 2
      ;;
    -v|--version)
      echo "claude-autonomous version ${VERSION}"
      echo "Part of issue-driven-development plugin"
      echo "https://github.com/troykelly/claude-skills"
      exit 0
      ;;
    -h|--help)
      head -38 "$0" | grep -E "^#" | sed 's/^# *//'
      exit 0
      ;;
    *)
      echo -e "${RED}Unknown option: $1${NC}"
      echo "Use --help for usage information"
      exit 1
      ;;
  esac
done

# Use WORK_EPIC env var if --epic not provided
EPIC="${EPIC:-${WORK_EPIC:-}}"

# Use WORK_PRS env var if --pr not provided with specific PRs
if [[ -n "${WORK_PRS:-}" && -z "$PRS" ]]; then
  PRS="${WORK_PRS}"
  PR_MODE=true
fi

# Session log format: timestamp session_id repo_name worktree_path details
# Example: 2026-01-03T12:00:00+00:00 abc-123 my-repo /tmp/claude-worktrees/my-repo/abc-123 epic=#42 "Title"

# Helper: get session info from log by session ID
get_session_info() {
  local session_id="$1"
  if [[ -f "$SESSION_LOG" ]]; then
    grep " ${session_id} " "$SESSION_LOG" | tail -1
  fi
}

# Helper: get most recent session line from log
get_latest_session() {
  if [[ -f "$SESSION_LOG" ]]; then
    tail -1 "$SESSION_LOG"
  fi
}

# Crash recovery loop - wraps claude invocations with auto-restart
# Usage: run_with_crash_recovery <session_id> [initial_prompt]
# If initial_prompt is provided, starts new session; otherwise resumes
run_with_crash_recovery() {
  local sid="$1"
  local initial_prompt="${2:-}"
  local max_crashes="${MAX_CRASHES:-10}"
  local crash_times=()
  local crash_window=60
  local crash_threshold=3
  local total_crashes=0
  local first_run=true
  local msg=""

  echo -e "${GREEN}Starting with crash recovery...${NC}"
  echo ""

  while true; do
    local exit_code=0
    if [[ "$first_run" == "true" ]]; then
      first_run=false
      if [[ -n "$initial_prompt" ]]; then
        claude --dangerously-skip-permissions --model "${CLAUDE_MODEL}" --session-id "${sid}" "${initial_prompt}" || exit_code=$?
      else
        claude --dangerously-skip-permissions --model "${CLAUDE_MODEL}" --resume "${sid}" || exit_code=$?
      fi
    else
      claude --dangerously-skip-permissions --model "${CLAUDE_MODEL}" --resume "${sid}" "$msg" || exit_code=$?
    fi

    # Exit code 0 means successful completion
    if [[ $exit_code -eq 0 ]]; then
      echo -e "${GREEN}Session completed successfully${NC}"
      return 0
    fi

    # Any non-zero exit triggers recovery
    local now
    now=$(date +%s)
    crash_times+=("$now")
    total_crashes=$((total_crashes + 1))

    echo -e "${YELLOW}Claude exited with code ${exit_code}${NC}"

    # Check max crash limit
    if (( total_crashes >= max_crashes )); then
      echo -e "${RED}Maximum crash limit reached (${total_crashes}/${max_crashes})${NC}"
      echo -e "${RED}Session ${sid} terminated due to excessive crashes${NC}"
      echo "Review logs and session state before retrying."
      return 1
    fi

    # Count recent crashes (for loop detection)
    local recent_crashes=0
    for t in "${crash_times[@]}"; do
      if (( now - t < crash_window )); then
        recent_crashes=$((recent_crashes + 1))
      fi
    done

    if (( recent_crashes >= crash_threshold )); then
      echo -e "${RED}⚠️  Rapid crash loop detected ($recent_crashes crashes in ${crash_window}s)${NC}"
      msg="CRITICAL: You have crashed $recent_crashes times in the last ${crash_window} seconds. This indicates a crash loop - something you are repeatedly doing is causing you to crash (likely OOM from large test output, or a runaway process). STOP and think carefully: What were you doing? Do NOT repeat the same action. Consider: 1) Running smaller test subsets, 2) Adding output limits, 3) Taking a different approach entirely. Explain your analysis before proceeding."
      sleep 10
    else
      echo -e "${YELLOW}Restarting after crash... (Session: ${sid}, crash ${total_crashes}/${max_crashes})${NC}"
      msg="You crashed or ran out of memory. This happens occasionally - continue where you left off autonomously."
      sleep 3
    fi
  done
}

# Handle --continue mode (resume most recent session)
if [[ "$CONTINUE_MODE" == "true" ]]; then
  # Check claude is available
  if ! command -v claude &>/dev/null; then
    echo -e "${RED}Error: claude CLI not found${NC}"
    exit 1
  fi

  LATEST=$(get_latest_session)
  if [[ -z "$LATEST" ]]; then
    echo -e "${YELLOW}No sessions in our log. Using Claude's native --continue with crash recovery...${NC}"
    echo ""
    # Simple crash recovery for native --continue (no session ID available)
    max_crashes="${MAX_CRASHES:-10}"
    total_crashes=0
    while true; do
      exit_code=0
      claude --dangerously-skip-permissions --model "${CLAUDE_MODEL}" --continue || exit_code=$?
      if [[ $exit_code -eq 0 ]]; then
        echo -e "${GREEN}Session completed successfully${NC}"
        exit 0
      fi
      total_crashes=$((total_crashes + 1))
      if (( total_crashes >= max_crashes )); then
        echo -e "${RED}Maximum crash limit reached (${total_crashes}/${max_crashes})${NC}"
        exit 1
      fi
      echo -e "${YELLOW}Claude exited with code ${exit_code}. Restarting... (crash ${total_crashes}/${max_crashes})${NC}"
      sleep 3
    done
  fi

  # Parse session info: timestamp session_id repo_name worktree_path details
  SESSION_ID=$(echo "$LATEST" | awk '{print $2}')
  SESSION_REPO=$(echo "$LATEST" | awk '{print $3}')
  SESSION_WORKTREE=$(echo "$LATEST" | awk '{print $4}')
  SESSION_DETAILS=$(echo "$LATEST" | cut -d' ' -f5-)

  echo -e "${CYAN}╔══════════════════════════════════════════════════════════════╗${NC}"
  echo -e "${CYAN}║${NC}              ${GREEN}Resuming Most Recent Session${NC}                     ${CYAN}║${NC}"
  echo -e "${CYAN}╚══════════════════════════════════════════════════════════════╝${NC}"
  echo ""
  echo -e "${BLUE}Session ID:${NC}   ${SESSION_ID}"
  echo -e "${BLUE}Repository:${NC}   ${SESSION_REPO}"
  echo -e "${BLUE}Worktree:${NC}     ${SESSION_WORKTREE}"
  echo -e "${BLUE}Details:${NC}      ${SESSION_DETAILS}"
  echo ""

  # Check if Claude session file exists before attempting resume
  encoded_path=$(echo "$SESSION_WORKTREE" | sed 's|/|-|g')
  session_file="${CLAUDE_PROJECTS_DIR}/${encoded_path}/${SESSION_ID}.jsonl"

  if [[ ! -f "$session_file" ]]; then
    echo -e "${RED}Error: No Claude session file found${NC}"
    echo ""
    echo -e "Expected: ${session_file}"
    echo ""
    echo "This session cannot be resumed. The conversation was either:"
    echo "  - Never saved (Claude crashed before saving)"
    echo "  - Manually deleted"
    echo "  - Created in a different environment"
    echo ""
    echo "Use 'claude-autonomous --list' to see resumable sessions."
    exit 1
  fi
  echo -e "${GREEN}Session file found${NC}"
  echo ""

  # Check if worktree exists, recreate if not
  if [[ ! -d "$SESSION_WORKTREE" ]]; then
    echo -e "${YELLOW}Worktree no longer exists. Recreating...${NC}"

    # We need to be in a git repo to create worktree
    if ! git rev-parse --show-toplevel &>/dev/null; then
      echo -e "${RED}Error: Not in a git repository${NC}"
      echo "Run this command from within the ${SESSION_REPO} repository"
      exit 1
    fi

    REPO_ROOT=$(git rev-parse --show-toplevel)
    CURRENT_REPO=$(basename "$REPO_ROOT")

    if [[ "$CURRENT_REPO" != "$SESSION_REPO" ]]; then
      echo -e "${YELLOW}Warning:${NC} Current repo (${CURRENT_REPO}) differs from session repo (${SESSION_REPO})"
    fi

    # Detect default branch
    DEFAULT_BRANCH=$(git remote show origin 2>/dev/null | grep 'HEAD branch' | cut -d: -f2 | tr -d ' ' || echo "main")
    if [[ -z "$DEFAULT_BRANCH" ]]; then
      if git rev-parse --verify origin/main &>/dev/null; then
        DEFAULT_BRANCH="main"
      elif git rev-parse --verify origin/master &>/dev/null; then
        DEFAULT_BRANCH="master"
      else
        echo -e "${RED}Error: Could not detect default branch${NC}"
        exit 1
      fi
    fi

    # Prune stale worktrees and fetch
    git worktree prune 2>/dev/null || true
    git fetch origin "${DEFAULT_BRANCH}" 2>/dev/null || true

    # Create parent directory if needed
    mkdir -p "$(dirname "$SESSION_WORKTREE")"

    # Create worktree at the exact same path
    if ! git worktree add "${SESSION_WORKTREE}" "origin/${DEFAULT_BRANCH}" 2>&1; then
      echo -e "${RED}Error: Failed to recreate worktree${NC}"
      echo "Try: git worktree prune && git worktree list"
      exit 1
    fi
    echo -e "${GREEN}Worktree recreated successfully${NC}"
    echo ""
  else
    echo -e "${GREEN}Worktree exists${NC}"
    echo ""
  fi

  # Change to worktree directory and resume
  cd "${SESSION_WORKTREE}" || {
    echo -e "${RED}Error: Cannot access worktree directory${NC}"
    exit 1
  }

  echo -e "${GREEN}Resuming session from worktree...${NC}"
  echo ""
  run_with_crash_recovery "${SESSION_ID}"
  exit $?
fi

# Handle --resume mode (interactive or specific session)
if [[ -n "$RESUME_SESSION" ]]; then
  # Check claude is available
  if ! command -v claude &>/dev/null; then
    echo -e "${RED}Error: claude CLI not found${NC}"
    exit 1
  fi

  echo -e "${CYAN}╔══════════════════════════════════════════════════════════════╗${NC}"
  echo -e "${CYAN}║${NC}              ${GREEN}Session Resume${NC}                                   ${CYAN}║${NC}"
  echo -e "${CYAN}╚══════════════════════════════════════════════════════════════╝${NC}"
  echo ""

  if [[ "$RESUME_SESSION" == "INTERACTIVE" ]]; then
    # Build list of resumable autonomous sessions
    if [[ ! -f "$SESSION_LOG" ]]; then
      echo -e "${YELLOW}No autonomous sessions recorded yet.${NC}"
      echo ""
      echo "Start an autonomous session first with: claude-autonomous"
      exit 0
    fi

    # Collect resumable sessions into arrays
    declare -a SESSION_IDS=()
    declare -a SESSION_REPOS=()
    declare -a SESSION_WORKTREES=()
    declare -a SESSION_DETAILS=()
    declare -a SESSION_STATUSES=()

    while read -r line; do
      [[ -z "$line" ]] && continue
      sid=$(echo "$line" | awk '{print $2}')
      repo=$(echo "$line" | awk '{print $3}')
      worktree=$(echo "$line" | awk '{print $4}')
      details=$(echo "$line" | cut -d' ' -f5-)

      # Check if Claude session file exists
      encoded_path=$(echo "$worktree" | sed 's|/|-|g')
      session_file="${CLAUDE_PROJECTS_DIR}/${encoded_path}/${sid}.jsonl"

      if [[ -f "$session_file" ]]; then
        SESSION_IDS+=("$sid")
        SESSION_REPOS+=("$repo")
        SESSION_WORKTREES+=("$worktree")
        SESSION_DETAILS+=("$details")
        SESSION_STATUSES+=("resumable")
      fi
    done < <(tail -20 "$SESSION_LOG" | tac)

    if [[ ${#SESSION_IDS[@]} -eq 0 ]]; then
      echo -e "${YELLOW}No resumable sessions found.${NC}"
      echo ""
      echo "Sessions may have been cleaned up or created in a different environment."
      echo "Start a new session with: claude-autonomous"
      exit 0
    fi

    # Interactive arrow-key menu
    selected=0
    num_sessions=${#SESSION_IDS[@]}

    # Terminal control
    tput_available=false
    if command -v tput &>/dev/null; then
      tput_available=true
    fi

    # Hide cursor
    if [[ "$tput_available" == "true" ]]; then
      tput civis 2>/dev/null || true
    fi

    # Restore cursor on exit
    cleanup_menu() {
      if [[ "$tput_available" == "true" ]]; then
        tput cnorm 2>/dev/null || true
      fi
      stty echo 2>/dev/null || true
    }
    trap cleanup_menu EXIT

    # Draw the menu
    draw_menu() {
      # Move cursor up to redraw (after first draw)
      if [[ "${menu_drawn:-false}" == "true" ]]; then
        printf "\033[%dA" $((num_sessions + 3))
      fi
      menu_drawn=true

      echo -e "${BLUE}Resumable Autonomous Sessions:${NC}                                              "
      echo -e "  ${YELLOW}↑/↓${NC} Navigate  ${YELLOW}Enter${NC} Select  ${YELLOW}q${NC} Quit                                  "
      echo ""

      for i in "${!SESSION_IDS[@]}"; do
        if [[ $i -eq $selected ]]; then
          # Highlighted row
          printf "  ${GREEN}▶${NC} ${BOLD}%-36s${NC} ${CYAN}%-14s${NC} %s\033[K\n" \
            "${SESSION_IDS[$i]:0:36}" "${SESSION_REPOS[$i]}" "${SESSION_DETAILS[$i]:0:30}"
        else
          printf "    %-36s %-14s %s\033[K\n" \
            "${SESSION_IDS[$i]:0:36}" "${SESSION_REPOS[$i]}" "${SESSION_DETAILS[$i]:0:30}"
        fi
      done
    }

    # Initial draw
    draw_menu

    # Read input
    while true; do
      # Read single character (disable echo, raw mode)
      IFS= read -rsn1 key

      case "$key" in
        $'\x1b')
          # Escape sequence - read next two chars for arrow keys
          read -rsn2 -t 0.1 rest
          case "$rest" in
            '[A') # Up arrow
              if [[ $selected -gt 0 ]]; then
                selected=$((selected - 1))
              fi
              ;;
            '[B') # Down arrow
              if [[ $selected -lt $((num_sessions - 1)) ]]; then
                selected=$((selected + 1))
              fi
              ;;
          esac
          ;;
        'k'|'K') # vim up
          if [[ $selected -gt 0 ]]; then
            selected=$((selected - 1))
          fi
          ;;
        'j'|'J') # vim down
          if [[ $selected -lt $((num_sessions - 1)) ]]; then
            selected=$((selected + 1))
          fi
          ;;
        'q'|'Q')
          cleanup_menu
          echo ""
          echo "Cancelled."
          exit 0
          ;;
        '')
          # Enter key
          break
          ;;
      esac

      draw_menu
    done

    # Cleanup terminal state
    cleanup_menu
    trap - EXIT
    echo ""

    # Get selected session
    idx=$selected
    RESUME_SESSION="${SESSION_IDS[$idx]}"
    SESSION_REPO="${SESSION_REPOS[$idx]}"
    SESSION_WORKTREE="${SESSION_WORKTREES[$idx]}"
    SELECTED_DETAILS="${SESSION_DETAILS[$idx]}"

    echo ""
    echo -e "${GREEN}Selected session: ${RESUME_SESSION}${NC}"
    echo -e "${BLUE}Repository:${NC}   ${SESSION_REPO}"
    echo -e "${BLUE}Worktree:${NC}     ${SESSION_WORKTREE}"
    echo -e "${BLUE}Details:${NC}      ${SELECTED_DETAILS}"
    echo ""

    # Check if worktree exists, recreate if not
    if [[ ! -d "$SESSION_WORKTREE" ]]; then
      echo -e "${YELLOW}Worktree no longer exists. Recreating...${NC}"

      # We need to be in a git repo to create worktree
      if ! git rev-parse --show-toplevel &>/dev/null; then
        echo -e "${RED}Error: Not in a git repository${NC}"
        echo "Run this command from within the ${SESSION_REPO} repository"
        exit 1
      fi

      REPO_ROOT=$(git rev-parse --show-toplevel)
      CURRENT_REPO=$(basename "$REPO_ROOT")

      if [[ "$CURRENT_REPO" != "$SESSION_REPO" ]]; then
        echo -e "${YELLOW}Warning:${NC} Current repo (${CURRENT_REPO}) differs from session repo (${SESSION_REPO})"
      fi

      # Detect default branch
      DEFAULT_BRANCH=$(git remote show origin 2>/dev/null | grep 'HEAD branch' | cut -d: -f2 | tr -d ' ' || echo "main")
      if [[ -z "$DEFAULT_BRANCH" ]]; then
        if git rev-parse --verify origin/main &>/dev/null; then
          DEFAULT_BRANCH="main"
        elif git rev-parse --verify origin/master &>/dev/null; then
          DEFAULT_BRANCH="master"
        else
          echo -e "${RED}Error: Could not detect default branch${NC}"
          exit 1
        fi
      fi

      # Prune stale worktrees and fetch
      git worktree prune 2>/dev/null || true
      git fetch origin "${DEFAULT_BRANCH}" 2>/dev/null || true

      # Create parent directory if needed
      mkdir -p "$(dirname "$SESSION_WORKTREE")"

      # Create worktree at the exact same path
      if ! git worktree add "${SESSION_WORKTREE}" "origin/${DEFAULT_BRANCH}" 2>&1; then
        echo -e "${RED}Error: Failed to recreate worktree${NC}"
        echo "Try: git worktree prune && git worktree list"
        exit 1
      fi
      echo -e "${GREEN}Worktree recreated successfully${NC}"
      echo ""
    else
      echo -e "${GREEN}Worktree exists${NC}"
      echo ""
    fi

    # Change to worktree directory and resume
    cd "${SESSION_WORKTREE}" || {
      echo -e "${RED}Error: Cannot access worktree directory${NC}"
      exit 1
    }

    echo -e "${GREEN}Resuming session from worktree...${NC}"
    echo ""
    run_with_crash_recovery "${RESUME_SESSION}"
    exit $?
  else
    # Specific session ID provided - look up worktree path and recreate if needed
    SESSION_INFO=$(get_session_info "$RESUME_SESSION")
    if [[ -n "$SESSION_INFO" ]]; then
      # Format: timestamp session_id repo_name worktree_path details
      SESSION_REPO=$(echo "$SESSION_INFO" | awk '{print $3}')
      SESSION_WORKTREE=$(echo "$SESSION_INFO" | awk '{print $4}')
      SELECTED_DETAILS=$(echo "$SESSION_INFO" | cut -d' ' -f5-)

      echo -e "${BLUE}Session ID:${NC}   ${RESUME_SESSION}"
      echo -e "${BLUE}Repository:${NC}   ${SESSION_REPO}"
      echo -e "${BLUE}Worktree:${NC}     ${SESSION_WORKTREE}"
      echo -e "${BLUE}Details:${NC}      ${SELECTED_DETAILS}"
      echo ""

      # Check if Claude session file exists before attempting resume
      encoded_path=$(echo "$SESSION_WORKTREE" | sed 's|/|-|g')
      session_file="${CLAUDE_PROJECTS_DIR}/${encoded_path}/${RESUME_SESSION}.jsonl"

      if [[ ! -f "$session_file" ]]; then
        echo -e "${RED}Error: No Claude session file found${NC}"
        echo ""
        echo -e "Expected: ${session_file}"
        echo ""
        echo "This session cannot be resumed. The conversation was either:"
        echo "  - Never saved (Claude crashed before saving)"
        echo "  - Manually deleted"
        echo "  - Created in a different environment"
        exit 1
      fi
      echo -e "${GREEN}Session file found${NC}"
      echo ""

      # Check if worktree exists, recreate if not
      if [[ ! -d "$SESSION_WORKTREE" ]]; then
        echo -e "${YELLOW}Worktree no longer exists. Recreating...${NC}"

        # We need to be in a git repo to create worktree
        if ! git rev-parse --show-toplevel &>/dev/null; then
          echo -e "${RED}Error: Not in a git repository${NC}"
          echo "Run this command from within the ${SESSION_REPO} repository"
          exit 1
        fi

        REPO_ROOT=$(git rev-parse --show-toplevel)
        CURRENT_REPO=$(basename "$REPO_ROOT")

        if [[ "$CURRENT_REPO" != "$SESSION_REPO" ]]; then
          echo -e "${YELLOW}Warning:${NC} Current repo (${CURRENT_REPO}) differs from session repo (${SESSION_REPO})"
        fi

        # Detect default branch
        DEFAULT_BRANCH=$(git remote show origin 2>/dev/null | grep 'HEAD branch' | cut -d: -f2 | tr -d ' ' || echo "main")
        if [[ -z "$DEFAULT_BRANCH" ]]; then
          if git rev-parse --verify origin/main &>/dev/null; then
            DEFAULT_BRANCH="main"
          elif git rev-parse --verify origin/master &>/dev/null; then
            DEFAULT_BRANCH="master"
          else
            echo -e "${RED}Error: Could not detect default branch${NC}"
            exit 1
          fi
        fi

        # Prune stale worktrees and fetch
        git worktree prune 2>/dev/null || true
        git fetch origin "${DEFAULT_BRANCH}" 2>/dev/null || true

        # Create parent directory if needed
        mkdir -p "$(dirname "$SESSION_WORKTREE")"

        # Create worktree at the exact same path
        if ! git worktree add "${SESSION_WORKTREE}" "origin/${DEFAULT_BRANCH}" 2>&1; then
          echo -e "${RED}Error: Failed to recreate worktree${NC}"
          echo "Try: git worktree prune && git worktree list"
          exit 1
        fi
        echo -e "${GREEN}Worktree recreated successfully${NC}"
        echo ""
      else
        echo -e "${GREEN}Worktree exists${NC}"
        echo ""
      fi

      # Change to worktree directory and resume
      cd "${SESSION_WORKTREE}" || {
        echo -e "${RED}Error: Cannot access worktree directory${NC}"
        exit 1
      }

      echo -e "${GREEN}Resuming session from worktree...${NC}"
      echo ""
      run_with_crash_recovery "${RESUME_SESSION}"
      exit $?
    else
      echo -e "${BLUE}Session ID:${NC}   ${RESUME_SESSION}"
      echo -e "${YELLOW}Note:${NC} Session not found in our log (may be a Claude-native session)"
      echo ""
      echo -e "${GREEN}Attempting resume...${NC}"
      echo ""
      # No worktree info available, so run from current directory
      run_with_crash_recovery "${RESUME_SESSION}"
      exit $?
    fi
  fi
fi

# Change to repo if specified
if [[ -n "$REPO_PATH" ]]; then
  if [[ ! -d "$REPO_PATH" ]]; then
    echo -e "${RED}Error: Directory does not exist: ${REPO_PATH}${NC}"
    exit 1
  fi
  cd "$REPO_PATH" || {
    echo -e "${RED}Error: Cannot access directory: ${REPO_PATH}${NC}"
    exit 1
  }
fi

# Verify we're in a git repository
if ! git rev-parse --show-toplevel &>/dev/null; then
  echo -e "${RED}Error: Not in a git repository${NC}"
  echo "Run this command from within a git repository, or use --repo <path>"
  exit 1
fi

# Verify origin remote exists
if ! git remote get-url origin &>/dev/null; then
  echo -e "${RED}Error: No 'origin' remote configured${NC}"
  echo "Add a remote with: git remote add origin <url>"
  exit 1
fi

# Check for required tools
check_tool() {
  if ! command -v "$1" &>/dev/null; then
    echo -e "${RED}Error: $1 is required but not installed${NC}"
    echo "Install with: $2"
    exit 1
  fi
}

check_tool "git" "apt-get install git / brew install git"
check_tool "gh" "https://cli.github.com/"
check_tool "claude" "curl -fsSL https://claude.ai/install.sh | bash"
check_tool "jq" "apt-get install jq / brew install jq"

# Check git version supports worktrees (added in git 2.5)
GIT_VERSION=$(git --version | grep -oE '[0-9]+\.[0-9]+' | head -1)
GIT_MAJOR=$(echo "$GIT_VERSION" | cut -d. -f1)
GIT_MINOR=$(echo "$GIT_VERSION" | cut -d. -f2)
if [[ "$GIT_MAJOR" -lt 2 ]] || [[ "$GIT_MAJOR" -eq 2 && "$GIT_MINOR" -lt 5 ]]; then
  echo -e "${RED}Error: git 2.5+ required for worktree support (found: $GIT_VERSION)${NC}"
  exit 1
fi

# Verify gh is authenticated
if ! gh auth status &>/dev/null; then
  echo -e "${RED}Error: GitHub CLI not authenticated${NC}"
  echo "Run: gh auth login"
  exit 1
fi

# Ensure GITHUB_TOKEN is set for MCP servers
if [[ -z "${GITHUB_TOKEN:-}" ]]; then
  echo -e "${YELLOW}GITHUB_TOKEN not set, fetching from gh CLI...${NC}"
  if GH_TOKEN=$(gh auth token 2>/dev/null); then
    export GITHUB_TOKEN="$GH_TOKEN"
    echo -e "${GREEN}GITHUB_TOKEN set from gh auth token${NC}"
  else
    echo -e "${RED}Error: Could not fetch GitHub token from gh CLI${NC}"
    echo "Ensure gh is authenticated with: gh auth login"
    exit 1
  fi
else
  echo -e "${GREEN}GITHUB_TOKEN already set${NC}"
fi

# Mutual exclusion: --epic and --pr cannot be used together
if [[ -n "$EPIC" && "$PR_MODE" == "true" ]]; then
  echo -e "${RED}Error: --epic and --pr cannot be used together${NC}"
  echo "Use --epic to work on issues, or --pr to resolve pull requests."
  exit 1
fi

# Validate epic issue exists and is open (if specified)
if [[ -n "$EPIC" ]]; then
  echo -e "${YELLOW}Validating Epic #${EPIC}...${NC}"

  # Fetch issue details
  ISSUE_JSON=$(gh issue view "$EPIC" --json state,title,url 2>/dev/null) || {
    echo -e "${RED}Error: Epic #${EPIC} not found in this repository${NC}"
    echo ""
    echo "Verify the issue number exists: gh issue list"
    exit 1
  }

  ISSUE_STATE=$(echo "$ISSUE_JSON" | jq -r '.state' 2>/dev/null) || ISSUE_STATE=""
  ISSUE_TITLE=$(echo "$ISSUE_JSON" | jq -r '.title' 2>/dev/null) || ISSUE_TITLE=""
  ISSUE_URL=$(echo "$ISSUE_JSON" | jq -r '.url' 2>/dev/null) || ISSUE_URL=""

  if [[ "$ISSUE_STATE" != "OPEN" ]]; then
    echo -e "${RED}Error: Epic #${EPIC} is ${ISSUE_STATE}${NC}"
    echo ""
    echo -e "Title: ${ISSUE_TITLE}"
    echo -e "URL:   ${CYAN}${ISSUE_URL}${NC}"
    echo ""
    echo "Reopen the issue if you want to work on it, then retry."
    exit 1
  fi

  echo -e "${GREEN}Epic #${EPIC} validated: ${ISSUE_TITLE}${NC}"
fi

# Validate and discover PRs (if --pr mode)
PR_LIST=""
PR_COUNT=0
if [[ "$PR_MODE" == "true" ]]; then
  echo -e "${YELLOW}Discovering PRs to resolve...${NC}"

  if [[ -n "$PRS" ]]; then
    # Validate specific PRs provided by user
    IFS=',' read -ra PR_ARRAY <<< "$PRS"
    VALID_PRS=()

    for pr in "${PR_ARRAY[@]}"; do
      pr=$(echo "$pr" | tr -d ' ')  # Trim whitespace
      [[ -z "$pr" ]] && continue

      PR_JSON=$(gh pr view "$pr" --json number,title,state,headRefName,labels 2>/dev/null) || {
        echo -e "${YELLOW}Warning: PR #${pr} not found, skipping${NC}"
        continue
      }

      PR_STATE=$(echo "$PR_JSON" | jq -r '.state')
      PR_TITLE=$(echo "$PR_JSON" | jq -r '.title')
      PR_BRANCH=$(echo "$PR_JSON" | jq -r '.headRefName')

      if [[ "$PR_STATE" != "OPEN" ]]; then
        echo -e "${YELLOW}Warning: PR #${pr} is ${PR_STATE}, skipping${NC}"
        continue
      fi

      # Check for exclusion labels
      HAS_EXCLUDE_LABEL=$(echo "$PR_JSON" | jq -r '.labels | map(.name) | if index("release-placeholder") or index("do-not-merge") then "yes" else "no" end')
      if [[ "$HAS_EXCLUDE_LABEL" == "yes" ]]; then
        echo -e "${YELLOW}Warning: PR #${pr} has exclusion label, skipping${NC}"
        continue
      fi

      # Check for release branch
      if [[ "$PR_BRANCH" == release/* ]]; then
        echo -e "${YELLOW}Warning: PR #${pr} is a release branch, skipping${NC}"
        continue
      fi

      echo -e "  ${GREEN}✓${NC} PR #${pr}: ${PR_TITLE}"
      VALID_PRS+=("$pr")
    done

    if [[ ${#VALID_PRS[@]} -eq 0 ]]; then
      echo -e "${RED}Error: No valid PRs to resolve${NC}"
      exit 1
    fi

    PR_LIST=$(IFS=','; echo "${VALID_PRS[*]}")
    PR_COUNT=${#VALID_PRS[@]}
  else
    # Discover all open PRs excluding release branches and specific labels
    echo -e "${BLUE}Finding all actionable open PRs...${NC}"

    ALL_PRS=$(gh pr list --json number,title,headRefName,labels --jq '
      [.[] | select(
        (.headRefName | startswith("release/") | not) and
        (.labels | map(.name) | index("release-placeholder") | not) and
        (.labels | map(.name) | index("do-not-merge") | not)
      )]
    ')

    PR_COUNT=$(echo "$ALL_PRS" | jq 'length')

    if [[ "$PR_COUNT" -eq 0 ]]; then
      echo -e "${YELLOW}No actionable PRs found${NC}"
      echo ""
      echo "All PRs are either:"
      echo "  - On release/* branches"
      echo "  - Have 'release-placeholder' label"
      echo "  - Have 'do-not-merge' label"
      exit 0
    fi

    # Build comma-separated list and display
    PR_LIST=$(echo "$ALL_PRS" | jq -r '.[].number' | tr '\n' ',' | sed 's/,$//')

    echo -e "${GREEN}Found ${PR_COUNT} actionable PRs:${NC}"
    echo "$ALL_PRS" | jq -r '.[] | "  #\(.number): \(.title)"'
  fi

  echo ""
  echo -e "${GREEN}PRs to resolve: ${PR_LIST}${NC}"
fi

# Generate session ID (date +%s%N is GNU-only, use $RANDOM for macOS fallback)
SESSION_ID=$(uuidgen 2>/dev/null || cat /proc/sys/kernel/random/uuid 2>/dev/null || echo "$(date +%s)-${RANDOM}-${RANDOM}")
REPO_ROOT=$(git rev-parse --show-toplevel)
REPO_NAME=$(basename "${REPO_ROOT}")
WORKTREE_DIR="/tmp/claude-worktrees/${REPO_NAME}/${SESSION_ID}"
MAX_CRASHES="${MAX_CRASHES:-10}"

# Detect default branch (main, master, or other)
DEFAULT_BRANCH=$(git remote show origin 2>/dev/null | grep 'HEAD branch' | cut -d: -f2 | tr -d ' ' || echo "main")
if [[ -z "$DEFAULT_BRANCH" ]]; then
  # Fallback: check if main or master exists
  if git rev-parse --verify origin/main &>/dev/null; then
    DEFAULT_BRANCH="main"
  elif git rev-parse --verify origin/master &>/dev/null; then
    DEFAULT_BRANCH="master"
  else
    echo -e "${RED}Error: Could not detect default branch${NC}"
    exit 1
  fi
fi

# Clean up stale worktrees from previous runs
echo -e "${YELLOW}Pruning stale worktrees...${NC}"
git worktree prune 2>/dev/null || true

# Log session with restricted permissions
mkdir -p /tmp/claude-worktrees
chmod 700 /tmp/claude-worktrees 2>/dev/null || true
# Log session with worktree path for reference
# Format: timestamp session_id repo_name worktree_path details
if [[ -n "$EPIC" ]]; then
  echo "$(date -Iseconds) ${SESSION_ID} ${REPO_NAME} ${WORKTREE_DIR} epic=#${EPIC} \"${ISSUE_TITLE}\"" >> /tmp/claude-sessions.txt
elif [[ "$PR_MODE" == "true" ]]; then
  echo "$(date -Iseconds) ${SESSION_ID} ${REPO_NAME} ${WORKTREE_DIR} prs=${PR_LIST} (${PR_COUNT} PRs)" >> /tmp/claude-sessions.txt
else
  echo "$(date -Iseconds) ${SESSION_ID} ${REPO_NAME} ${WORKTREE_DIR} scope=all" >> /tmp/claude-sessions.txt
fi
chmod 600 /tmp/claude-sessions.txt 2>/dev/null || true

echo -e "${CYAN}╔══════════════════════════════════════════════════════════════╗${NC}"
echo -e "${CYAN}║${NC}          ${GREEN}Claude Autonomous Issue-Driven Development${NC}          ${CYAN}║${NC}"
echo -e "${CYAN}╚══════════════════════════════════════════════════════════════╝${NC}"
echo ""
echo -e "${BLUE}Session ID:${NC}   ${SESSION_ID}"
echo -e "${BLUE}Repository:${NC}   ${REPO_NAME}"
echo -e "${BLUE}Branch:${NC}       ${DEFAULT_BRANCH}"
echo -e "${BLUE}Worktree:${NC}     ${WORKTREE_DIR}"
echo -e "${BLUE}GitHub Token:${NC} ${GREEN}✓ Set${NC}"
echo -e "${BLUE}Model:${NC}        ${CLAUDE_MODEL}"
echo -e "${BLUE}Max Crashes:${NC}  ${MAX_CRASHES}"

# Show multi-account status if available
if has_multi_account_support; then
  ACCOUNT_CMD=$(get_claude_account_cmd)
  if [[ -n "$ACCOUNT_CMD" ]]; then
    # Extract email from current output (strip ANSI codes first, then extract email)
    CURRENT_OUTPUT=$("$ACCOUNT_CMD" current 2>/dev/null) || CURRENT_OUTPUT=""
    CURRENT_OUTPUT_CLEAN=$(echo "$CURRENT_OUTPUT" | sed 's/\x1b\[[0-9;]*m//g')
    CURRENT_ACCOUNT=$(echo "$CURRENT_OUTPUT_CLEAN" | grep -oE '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}' | head -1) || true
    [[ -z "$CURRENT_ACCOUNT" ]] && CURRENT_ACCOUNT="unknown"

    # Count available accounts (--available outputs just emails)
    # Note: grep -c returns 1 when no matches, so we capture separately and handle the exit code
    AVAILABLE_OUTPUT=$("$ACCOUNT_CMD" list --available 2>/dev/null) || AVAILABLE_OUTPUT=""
    AVAILABLE_COUNT=$(echo "$AVAILABLE_OUTPUT" | grep -c '@') || AVAILABLE_COUNT=0

    # Get total from "Total: N account(s)" line
    LIST_OUTPUT=$("$ACCOUNT_CMD" list 2>/dev/null) || LIST_OUTPUT=""
    TOTAL_LINE=$(echo "$LIST_OUTPUT" | grep "^Total:") || TOTAL_LINE=""
    TOTAL_COUNT=$(echo "$TOTAL_LINE" | grep -oE '[0-9]+' | head -1) || TOTAL_COUNT=""
    [[ -z "$TOTAL_COUNT" ]] && TOTAL_COUNT="$AVAILABLE_COUNT"

    echo -e "${BLUE}Account:${NC}      ${CURRENT_ACCOUNT}"
    if [[ "$AVAILABLE_COUNT" -gt 0 ]]; then
      echo -e "${BLUE}Accounts:${NC}     ${GREEN}${AVAILABLE_COUNT}/${TOTAL_COUNT} available${NC}"
    else
      echo -e "${BLUE}Accounts:${NC}     ${YELLOW}${TOTAL_COUNT} total (cooldown status unknown)${NC}"
    fi
    echo -e "${BLUE}Max Switches:${NC} ${MAX_ACCOUNT_SWITCHES} per session"
  fi
fi

if [[ "$NEW_MODE" == "true" ]]; then
  echo -e "${BLUE}Mode:${NC}         ${CYAN}Interactive (waiting for instructions)${NC}"
elif [[ "$PR_MODE" == "true" ]]; then
  echo -e "${BLUE}Mode:${NC}         ${CYAN}PR Resolution${NC}"
  echo -e "${BLUE}PRs:${NC}          ${PR_LIST} (${PR_COUNT} total)"
elif [[ -n "$EPIC" ]]; then
  echo -e "${BLUE}Focus Epic:${NC}   #${EPIC} - ${ISSUE_TITLE}"
  echo -e "${BLUE}Epic URL:${NC}     ${CYAN}${ISSUE_URL}${NC}"
else
  echo -e "${BLUE}Scope:${NC}        All open issues and epics"
fi
echo ""

# Fetch and create worktree
echo -e "${YELLOW}Creating isolated worktree from origin/${DEFAULT_BRANCH}...${NC}"
if ! git fetch origin "${DEFAULT_BRANCH}" 2>&1; then
  echo -e "${RED}Error: Failed to fetch origin/${DEFAULT_BRANCH}${NC}"
  echo "Check your network connection and remote configuration."
  exit 1
fi
if ! git worktree add "${WORKTREE_DIR}" "origin/${DEFAULT_BRANCH}" 2>&1; then
  echo -e "${RED}Error: Failed to create worktree${NC}"
  echo "Try: git worktree prune && git worktree list"
  exit 1
fi
echo -e "${GREEN}Worktree created successfully${NC}"
echo ""

# Cleanup function - ONLY cleans up on successful exit (exit code 0)
# Non-zero exits preserve the worktree to avoid losing uncommitted work
CLEANUP_DONE=false
cleanup() {
  if [[ "$CLEANUP_DONE" == "true" ]]; then
    return 0
  fi
  CLEANUP_DONE=true
  local exit_code=$?
  echo ""

  if [[ $exit_code -eq 0 ]]; then
    echo -e "${YELLOW}Session completed successfully. Cleaning up worktree...${NC}"
    cd "${REPO_ROOT}" 2>/dev/null || true
    git worktree remove --force "${WORKTREE_DIR}" 2>/dev/null || true
    git worktree prune 2>/dev/null || true
    echo -e "${GREEN}Session ${SESSION_ID} ended at $(date -Iseconds)${NC}"
  else
    echo -e "${YELLOW}Session exited with code ${exit_code}. Preserving worktree for recovery.${NC}"
    echo -e "${BLUE}Worktree preserved at:${NC} ${WORKTREE_DIR}"
    echo -e "${BLUE}Resume with:${NC} claude-autonomous --resume ${SESSION_ID}"
    echo ""
    echo -e "${YELLOW}To manually cleanup later:${NC}"
    echo -e "  cd ${REPO_ROOT} && git worktree remove ${WORKTREE_DIR}"
  fi
  exit $exit_code
}

# Handle cleanup on exit only - signals are handled by the crash recovery loop
# INT/TERM signals are ignored to parent (set at script start) so Claude receives them
# When Claude exits from a signal, the crash recovery loop catches it and restarts
trap cleanup EXIT

# Change to worktree
cd "${WORKTREE_DIR}"

# Build initial prompt based on mode
if [[ "$NEW_MODE" == "true" ]]; then
  # Interactive mode: bootstrap and wait for instructions
  INITIAL_PROMPT="You are working in an isolated git worktree at: ${WORKTREE_DIR}

This worktree was created from origin/${DEFAULT_BRANCH} to allow autonomous work without affecting the main repository. Your session ID is ${SESSION_ID}.

ENVIRONMENT SETUP:
- Isolated worktree from origin/${DEFAULT_BRANCH}
- GitHub token configured for API access
- Full autonomous permissions enabled
- Crash recovery with session resumption

WORKFLOW CAPABILITIES:
- Create feature branches for work and push to origin
- Create GitHub issues to track work
- Open PRs when work is complete (do not merge directly to ${DEFAULT_BRANCH})
- Use issue-driven development skills for structured work
- Run tests, builds, and verification

READY FOR INSTRUCTIONS:
I am bootstrapped and ready. Please provide your instructions - for example:
- 'Here is a list of bugs in bugs.txt - create issues for each and resolve them'
- 'Implement the features described in FEATURES.md'
- 'Review and fix all TypeScript errors in the codebase'

What would you like me to work on?"
elif [[ "$PR_MODE" == "true" ]]; then
  # PR Resolution mode: focus on resolving PRs through full lifecycle
  INITIAL_PROMPT="You are working in an isolated git worktree at: ${WORKTREE_DIR}

This worktree was created from origin/${DEFAULT_BRANCH} for PR resolution. Your session ID is ${SESSION_ID}.

MISSION: Resolve the following PRs through their full lifecycle:
PRs: ${PR_LIST}

FULL LIFECYCLE FOR EACH PR:
1. **Check CI Status** - Are all checks passing?
   - If ANY check is failing: investigate, fix, push, wait for green
   - Continue fixing until ALL checks pass

2. **Verify Review Artifact** - Does a comprehensive review comment exist?
   - Look for structured review comments (<!-- REVIEW:START --> markers)
   - If missing: perform comprehensive code review and post artifact

3. **Check Merge Eligibility** - Can this PR be merged?
   - Check for 'do-not-merge' label → Skip merge, move to next PR
   - Check for comments blocking merge → Skip merge, move to next PR
   - If merge is permitted: squash merge and delete branch

4. **Mark Linked Issue Done** - Update project board status

PARALLEL EXECUTION:
- You are an orchestrator - spawn worker agents for parallel PR resolution
- Use Task tool with run_in_background: true for each PR
- Monitor workers with TaskOutput (block: false)
- Maximum 5 concurrent workers

WORKER SETUP:
Each worker needs its own isolated environment. Before spawning:
1. Create a worktree for the PR: git worktree add ../\$(basename \$PWD)-pr-[NUMBER] [PR_BRANCH]
2. Worker operates in that worktree directory

WORKER PROMPT TEMPLATE:
Each spawned worker should receive a prompt like:

\"\"\"
You are a PR resolution worker. Your task is to resolve PR #[NUMBER].

SETUP:
cd [WORKTREE_PATH]  # Your isolated worktree on the PR branch

LIFECYCLE:
1. Check CI status: gh pr checks [NUMBER]
2. If failing: read logs, fix code, commit, push, wait for green
3. If passing: verify review artifact exists in linked issue
4. If review missing: perform code review and post artifact
5. Check merge eligibility: no 'do-not-merge' label, no blocking comments
6. If eligible: gh pr merge [NUMBER] --squash --delete-branch
7. Report: PR merged OR blocked (with reason)

CONSTRAINTS:
- Only fix code directly related to CI failures
- Always push to the existing PR branch (do not create new branches)
- Use 'gh pr merge' with --squash --delete-branch

EXIT when: PR is merged OR you determine it cannot be merged autonomously.
\"\"\"

PR RESOLUTION ORDER:
Process PRs in the order listed. For each:
1. Create isolated worktree for the PR
2. Spawn a worker agent with the worktree path
3. Worker fixes CI if failing
4. Worker posts review artifact if missing
5. Worker merges if permitted
6. Worker reports completion or blockage
7. Clean up worktree after worker completes

CONSTRAINTS:
- Do NOT modify code unrelated to failing CI
- Do NOT merge PRs with 'do-not-merge' label
- Do NOT merge if comments indicate human review required
- Always squash merge, always delete branch after merge

BEGIN:
Start by checking the status of each PR and spawning workers for parallel resolution."
else
  # Standard autonomous mode
  if [[ -n "$EPIC" ]]; then
    EPIC_INSTRUCTION="Focus exclusively on Epic #${EPIC} and its child issues. Do not work on unrelated issues."
  else
    EPIC_INSTRUCTION="Work through all open epics and issues in priority order."
  fi

  INITIAL_PROMPT="You are working in an isolated git worktree at: ${WORKTREE_DIR}

This worktree was created from origin/${DEFAULT_BRANCH} to allow multiple agents to work in parallel without conflicts. Your session ID is ${SESSION_ID}.

IMPORTANT WORKFLOW NOTES:
- You have your own isolated copy of the codebase - other agents may be working in parallel
- Create feature branches for your work and push them to origin
- Open PRs when work is complete - do not merge directly to ${DEFAULT_BRANCH}
- If you need latest changes from ${DEFAULT_BRANCH}, you can pull origin/${DEFAULT_BRANCH} into your worktree

TASK: Use your issue driven development skill to work wholly autonomously until all assigned work is complete.

${EPIC_INSTRUCTION}"
fi

# Crash tracking
CRASH_TIMES=()
CRASH_WINDOW=60
CRASH_THRESHOLD=3
TOTAL_CRASHES=0
FIRST_RUN=true

echo -e "${GREEN}Starting autonomous operation...${NC}"
echo ""

# Export SESSION_ID so hooks can create session-specific state files
export CLAUDE_AUTONOMOUS_SESSION_ID="${SESSION_ID}"

# Run Claude with crash recovery loop
while true; do
  # Capture exit code without triggering set -e
  EXIT_CODE=0
  if [[ "$FIRST_RUN" == "true" ]]; then
    FIRST_RUN=false
    claude --dangerously-skip-permissions --model "${CLAUDE_MODEL}" --session-id "${SESSION_ID}" "${INITIAL_PROMPT}" || EXIT_CODE=$?
  else
    claude --dangerously-skip-permissions --model "${CLAUDE_MODEL}" --resume "${SESSION_ID}" "$MSG" || EXIT_CODE=$?
  fi

  # Exit code 0 means successful completion (user quit or work finished)
  if [[ $EXIT_CODE -eq 0 ]]; then
    echo -e "${GREEN}Session completed successfully${NC}"
    break
  fi

  # Any non-zero exit (crash, OOM, killed, plan limit) triggers recovery
  NOW=$(date +%s)

  echo -e "${YELLOW}Claude exited with code ${EXIT_CODE}${NC}"

  # Check if the Stop hook already performed an account switch
  # (Hook writes session-specific file to CLAUDE_STATE_DIR)
  PENDING_SWITCH_FILE="${CLAUDE_STATE_DIR}/.pending-account-switch.${SESSION_ID}"
  if [[ -f "$PENDING_SWITCH_FILE" ]]; then
    SWITCH_TO=$(jq -r '.to // empty' "$PENDING_SWITCH_FILE" 2>/dev/null) || SWITCH_TO=""
    SWITCH_FROM=$(jq -r '.from // empty' "$PENDING_SWITCH_FILE" 2>/dev/null) || SWITCH_FROM=""
    rm -f "$PENDING_SWITCH_FILE"

    if [[ -n "$SWITCH_TO" ]]; then
      echo -e "${GREEN}Account switched by hook: ${SWITCH_FROM} → ${SWITCH_TO}${NC}"
      ACCOUNT_SWITCH_COUNT=$((ACCOUNT_SWITCH_COUNT + 1))

      if (( ACCOUNT_SWITCH_COUNT >= MAX_ACCOUNT_SWITCHES )); then
        echo -e "${RED}Maximum account switches ($MAX_ACCOUNT_SWITCHES) reached${NC}" >&2
        exit 1
      fi

      MSG="Plan limit reached on ${SWITCH_FROM}. Now using ${SWITCH_TO}. Continue your work autonomously."
      sleep 2
      continue
    fi
  fi

  # Check if hook signaled sleep mode (all accounts exhausted)
  # (Hook writes session-specific file to CLAUDE_STATE_DIR)
  SLEEP_FILE="${CLAUDE_STATE_DIR}/.account-sleep-mode.${SESSION_ID}"
  if [[ -f "$SLEEP_FILE" ]]; then
    COOLDOWN_MINS=$(jq -r '.cooldown_minutes // 5' "$SLEEP_FILE" 2>/dev/null) || COOLDOWN_MINS=5
    [[ -z "$COOLDOWN_MINS" || ! "$COOLDOWN_MINS" =~ ^[0-9]+$ ]] && COOLDOWN_MINS=5
    rm -f "$SLEEP_FILE"
    echo -e "${YELLOW}All accounts exhausted. Waiting ${COOLDOWN_MINS} minutes for cooldown...${NC}"
    sleep $((COOLDOWN_MINS * 60))
    MSG="Plan limit cooldown complete. Resuming autonomous work."
    continue
  fi

  # Track crashes (only if not a hook-handled account switch)
  CRASH_TIMES+=("$NOW")
  TOTAL_CRASHES=$((TOTAL_CRASHES + 1))

  # Check if exit might be due to plan limits (fallback if hook didn't handle it)
  if has_multi_account_support; then
    # Check if current account is marked as exhausted (by Stop hook or explicit)
    ACCOUNT_CMD=$(get_claude_account_cmd)
    if [[ -n "$ACCOUNT_CMD" ]] && "$ACCOUNT_CMD" is-exhausted 2>/dev/null; then
      echo -e "${YELLOW}Account marked as exhausted (plan limit likely reached)${NC}"

      if try_switch_account; then
        # Successfully switched - reset crash count and continue
        MSG="Plan limit reached on previous account. Account switched successfully. Continue your work autonomously."
        sleep 2
        continue
      else
        # No accounts available - wait for cooldown
        wait_for_account_cooldown
        MSG="Plan limit cooldown complete. Resuming autonomous work."
        continue
      fi
    fi
  fi

  # Check max crash limit
  if (( TOTAL_CRASHES >= MAX_CRASHES )); then
    echo -e "${RED}Maximum crash limit reached (${TOTAL_CRASHES}/${MAX_CRASHES})${NC}"
    echo -e "${RED}Session ${SESSION_ID} terminated due to excessive crashes${NC}"
    echo "Review logs and session state before retrying."
    exit 1
  fi

  # Count recent crashes (for loop detection)
  RECENT_CRASHES=0
  for T in "${CRASH_TIMES[@]}"; do
    if (( NOW - T < CRASH_WINDOW )); then
      RECENT_CRASHES=$((RECENT_CRASHES + 1))
    fi
  done

  if (( RECENT_CRASHES >= CRASH_THRESHOLD )); then
    echo -e "${RED}⚠️  Rapid crash loop detected ($RECENT_CRASHES crashes in ${CRASH_WINDOW}s)${NC}"
    MSG="CRITICAL: You have crashed $RECENT_CRASHES times in the last ${CRASH_WINDOW} seconds. This indicates a crash loop - something you are repeatedly doing is causing you to crash (likely OOM from large test output, or a runaway process). STOP and think carefully: What were you doing? Do NOT repeat the same action. Consider: 1) Running smaller test subsets, 2) Adding output limits, 3) Taking a different approach entirely. Explain your analysis before proceeding."
    sleep 10
  else
    echo -e "${YELLOW}Restarting after crash... (Session: ${SESSION_ID}, crash ${TOTAL_CRASHES}/${MAX_CRASHES})${NC}"
    MSG="You crashed or ran out of memory. This happens occasionally - continue where you left off autonomously."
    sleep 3
  fi
done
